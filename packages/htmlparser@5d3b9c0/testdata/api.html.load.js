montageDefine("5d3b9c0","testdata/api.html",{text:"<!DOCTYPE html>\n<head> \n	<meta http-equiv=Content-Type content=\"text/html; charset=utf-8\">\n	<meta name=generator value=\"Ronn/v0.4.1\"> \n	<title>node(1) -- evented I/O for V8 JavaScript</title> \n	<style type=\"text/css\"> \n		*{\n			margin: 0;padding: 0;\n		}\n		html,body\n		{\n			height: 100%;\n		}\n		body\n		{\n			font-family:helvetica, arial, sans serif;\n			background:#22252a;\n			color:#eee;\n			font-size:16px;\n      line-height:1.3;\n			position:relative;\n			min-width: 690px;\n		}\n		a\n		{\n			color:#CD5;\n		}\n		a:focus\n		{\n			outline: none;\n			-moz-outline: none;\n		}\n		pre\n		{\n			overflow: hidden;\n		}\n		li\n		{\n			list-style: inside;\n		}\n		#man,#man code,#man pre,#man tt,#man kbd,#man samp\n		{\n			line-height:1.6;\n			color:#eee;\n			background:#22252a;\n		}\n\n		#man\n		{\n			margin: 0;\n			position: absolute;\n			top:0;\n			bottom:0;\n			left: 225px;\n			right: 0;\n			overflow: auto;\n		}\n		#man-content\n		{\n			padding: 0 20px;\n			max-width: 650px;\n		}\n		#man h1,#man h2,#man h3\n		{\n			color:#DCDDDE;\n			clear:left;		\n		}\n\n		#man h1\n		{\n			background:url(\"http://nodejs.org/logo.png\") no-repeat scroll center 0 transparent;\n			height:111px;\n			margin:15px 0 20px;\n			text-align:center;\n			text-indent:-2000px;\n		}\n\n		#man h2\n		{\n			font-size:18px;\n			background:#000;\n			color:#CD5;\n			margin:10px 0;\n			padding:5px 10px;\n		}\n\n		#man h3\n		{\n			font-size:16px;\n			margin:0 0 0 0ex;\n		}\n\n		#man p,#man ul,#man ol,#man dl,#man pre\n		{\n			margin:0 0 18px;\n		}\n\n		#man pre\n		{\n			color:#CCCDCE;\n			background:#121314;\n			border-left:2ex solid #222;\n			margin:0 0 20px;\n			padding:5px 7px;\n		}\n\n		#man pre + h2,#man pre + h3\n		{\n			margin-top:22px;\n		}\n\n		#man h2 + pre,#man h3 + pre\n		{\n			margin-top:5px;\n		}\n\n		#man > p,#man > ul,#man > ol,#man > dl,#man > pre\n		{\n			margin-left:5%;\n		}\n\n		#man dt\n		{\n			clear:left;\n			margin:0;\n		}\n\n		#man dt.flush\n		{\n			float:left;\n			width:8ex;\n		}\n\n		#man dd\n		{\n			margin:0 0 0 9ex;\n		}\n\n		#man code,#man strong,#man b\n		{\n			font-weight:bold;\n			color:#ECEDEE;\n		}\n\n		#man pre code\n		{\n			font-weight:normal;\n			color:#DCDDDE;\n			background:inherit;\n		}\n\n		#man em,var,u\n		{\n			font-style:normal;\n			color:#CCCDCE;\n			border-bottom:1px solid #999;\n		}\n\n		#man ol.man,#man ol.man li\n		{\n			float:left;\n			width:33%;\n			list-style-type:none;\n			text-transform:uppercase;\n			font-size:18px;\n			color:#666;\n			letter-spacing:1px;\n			margin:2px 0 10px;\n			padding:0;\n		}\n\n		#man ol.man\n		{\n			width:100%;\n		}\n\n		#man ol.man li.tl\n		{\n			text-align:left;\n		}\n\n		#man ol.man li.tc\n		{\n			text-align:center;\n			letter-spacing:4px;\n		}\n\n		#man ol.man li.tr\n		{\n			text-align:right;\n		}\n\n		#man ol.man a\n		{\n			color:#666;\n		}\n\n		#man ol.man a:hover\n		{\n			color:#CCCDCE;\n		}\n\n		#toc\n		{\n			position: absolute;\n			top:0;\n			bottom:0;\n			left: 0;\n			padding-left: 30px;\n			width: 195px;\n			overflow: auto;\n			overflow-x: hidden;\n			font-size: 15px;\n		}\n		#toc li\n		{\n			text-wrap: word-wrap;\n		}\n		#toc a\n		{\n			display: inline-block;\n			width: 100%;\n			color: #fff;\n			text-decoration:none;\n		}\n		#toc > a:hover\n		{\n			color: rgba(255,255,255,0.7);\n		}\n		#toc > ul > li\n		{\n			border-bottom:1px solid #0f1214;\n			padding:5px 0 5px 5px;\n			list-style: none;\n			line-height: 1.3;\n		}\n		#toc ul ul\n		{\n			display: none;\n		}\n		#toc ul ul > li\n		{\n			border-top:1px solid rgba(0, 0, 0, 0.1);\n			color:#FFFFFF;\n			font-size:85%;\n			line-height:1.3;\n			list-style:disc outside none;\n			margin-left:25px;\n			max-width:165px;\n			padding:3px 0 5px 5px;\n		}\n		#toc li.active > a\n		{\n			color:#CD5;\n		}\n\n		.sh_sourceCode\n		{\n			font-family: monospace;\n			overflow:hidden;\n		}\n\n		#toc .toggler\n		{\n			-moz-user-select:none;\n			background:none repeat scroll 0 0 #000000;\n			color:#FFFFFF;\n			display:inline-block;\n			font-weight:bold;\n			height:31px;\n			line-height:32px;\n			margin:-5px 8px -18px -33px;\n			outline:medium none;\n			padding:0;\n			text-align:center;\n			width:25px;\n		}\n		.current-section\n		{\n			position: fixed;\n			top: 0;\n			margin: 0 !important;\n		}\n		#toctitle\n		{\n			background:none repeat scroll 0 0 #000000;\n			color:#CCDD55;\n			font-size:18px;\n			margin: 0 0 10px -30px;\n			padding: 10px;\n		}\n	</style>\n<link rel=stylesheet href=\"./sh_vim-dark.css\" type=\"text/css\">\n</head>\n<body>\n\n<div id=toc>\n	<div id=toctitle>Node v0.1.99</div>\n	<noscript>JavaScript must be enabled in your browser to display the table of contents.</noscript>\n</div>\n<div id=man>\n<div id=man-content>\n<h1 class=man-title>node(1)</h1>\n\n<ol class=\"head man\">\n  <li class=tl>node(1)</li>\n\n  <li class=tc></li>\n  <li class=tr>node(1)</li>\n</ol>\n<h2 id=NAME>NAME</h2>\n<p><code>node</code> -- evented I/O for V8 JavaScript</p>\n\n<h2 id=Synopsis>Synopsis</h2>\n\n<p>An example of a web server written with Node which responds with 'Hello\nWorld':</p>\n\n<pre><code>var sys = require('sys'),\n  http = require('http');\n\nhttp.createServer(function (request, response) {\n  response.writeHead(200, {'Content-Type': 'text/plain'});\n  response.end('Hello World\\n');\n}).listen(8124);\n\nsys.puts('Server running at http://127.0.0.1:8124/');\n</code></pre>\n\n<p>To run the server, put the code into a file called <code>example.js</code> and execute\nit with the node program</p>\n\n<pre><code>&gt; node example.js\nServer running at http://127.0.0.1:8124/\n</code></pre>\n\n<p>All of the examples in the documentation can be run similarly.</p>\n\n<h2 id=\"Standard Modules\">Standard Modules</h2>\n\n<p>Node comes with a number of modules that are compiled in to the process,\nmost of which are documented below.  The most common way to use these modules\nis with <code>require('name')</code> and then assigning the return value to a local\nvariable with the same name as the module.</p>\n\n<p>Example:</p>\n\n<pre><code>var sys = require('sys');\n</code></pre>\n\n<p>It is possible to extend node with other modules.  See <code>'Modules'</code></p>\n\n<h2 id=Buffers>Buffers</h2>\n\n<p>Pure Javascript is Unicode friendly but not nice to binary data.  When\ndealing with TCP streams or the file system, it's necessary to handle octet\nstreams. Node has several strategies for manipulating, creating, and\nconsuming octet streams.</p>\n\n<p>Raw data is stored in instances of the <code>Buffer</code> class. A <code>Buffer</code> is similar\nto an array of integers but corresponds to a raw memory allocation outside\nthe V8 heap. A <code>Buffer</code> cannot be resized.\nAccess the class with <code>require('buffer').Buffer</code>.</p>\n\n<p>Converting between Buffers and JavaScript string objects requires an explicit encoding\nmethod.  Node supports 3 string encodings: UTF-8 (<code>'utf8'</code>), ASCII (<code>'ascii'</code>), and\nBinary (<code>'binary'</code>).</p>\n\n<ul>\n<li><p><code>'ascii'</code> - for 7 bit ASCII data only.  This encoding method is very fast, and will\nstrip the high bit if set.</p></li>\n<li><p><code>'binary'</code> - for 8 bit binary data such as images.</p></li>\n<li><p><code>'utf8'</code> - Unicode characters.  Many web pages and other document formats use UTF-8.</p></li>\n</ul>\n\n\n<h3>new Buffer(size)</h3>\n\n<p>Allocates a new buffer of <code>size</code> octets.</p>\n\n<h3>new Buffer(array)</h3>\n\n<p>Allocates a new buffer using an <code>array</code> of octets.</p>\n\n<h3>new Buffer(str, encoding = 'utf8')</h3>\n\n<p>Allocates a new buffer containing the given <code>str</code>.</p>\n\n<h3>buffer.write(string, encoding, offset)</h3>\n\n<p>Writes <code>string</code> to the buffer at <code>offset</code> using the given encoding. Returns\nnumber of octets written.  If <code>buffer</code> did not contain enough space to fit\nthe entire string it will write a partial amount of the string. In the case\nof <code>'utf8'</code> encoding, the method will not write partial characters.</p>\n\n<p>Example: write a utf8 string into a buffer, then print it</p>\n\n<pre><code>var sys = require('sys'),\n  Buffer = require('buffer').Buffer,\n  buf = new Buffer(256),\n  len;\n\nlen = buf.write('\\u00bd + \\u00bc = \\u00be', 'utf8', 0);\nsys.puts(len + \" bytes: \" + buf.toString('utf8', 0, len));\n\n// 12 bytes: ½ + ¼ = ¾\n</code></pre>\n\n<h3>buffer.toString(encoding, start, end)</h3>\n\n<p>Decodes and returns a string from buffer data encoded with <code>encoding</code>\nbeginning at <code>start</code> and ending at <code>end</code>.</p>\n\n<p>See <code>buffer.write()</code> example, above.</p>\n\n<h3>buffer[index]</h3>\n\n<p>Get and set the octet at <code>index</code>. The values refer to individual bytes,\nso the legal range is between <code>0x00</code> and <code>0xFF</code> hex or <code>0</code> and <code>255</code>.</p>\n\n<p>Example: copy an ASCII string into a buffer, one byte at a time:</p>\n\n<pre><code>var sys = require('sys'),\n  Buffer = require('buffer').Buffer,\n  str = \"node.js\",\n  buf = new Buffer(str.length),\n  i;\n\nfor (i = 0; i &lt; str.length ; i += 1) {\n  buf[i] = str.charCodeAt(i);\n}\n\nsys.puts(buf);\n\n// node.js\n</code></pre>\n\n<h3>Buffer.byteLength(string, encoding)</h3>\n\n<p>Gives the actual byte length of a string.  This is not the same as\n<code>String.prototype.length</code> since that returns the number of <em>characters</em> in a\nstring.</p>\n\n<p>Example:</p>\n\n<pre><code>var sys = require('sys'),\n  Buffer = require('buffer').Buffer,\n  str = '\\u00bd + \\u00bc = \\u00be';\n\nsys.puts(str + \": \" + str.length + \" characters, \" + \n  Buffer.byteLength(str, 'utf8') + \" bytes\");\n\n// ½ + ¼ = ¾: 9 characters, 12 bytes\n</code></pre>\n\n<h3>buffer.length</h3>\n\n<p>The size of the buffer in bytes.  Note that this is not necessarily the size\nof the contents. <code>length</code> refers to the amount of memory allocated for the\nbuffer object.  It does not change when the contents of the buffer are changed.</p>\n\n<pre><code>var sys = require('sys'),\n  Buffer = require('buffer').Buffer,\n  buf = new Buffer(1234);\n\nsys.puts(buf.length);\nbuf.write(\"some string\", \"ascii\", 0);\nsys.puts(buf.length);\n\n// 1234\n// 1234\n</code></pre>\n\n<h3>buffer.copy(targetBuffer, targetStart, sourceStart, sourceEnd)</h3>\n\n<p>Does a memcpy() between buffers.</p>\n\n<p>Example: build two Buffers, then copy <code>buf1</code> from byte 16 through byte 20\ninto <code>buf2</code>, starting at the 8th byte in <code>buf2</code>.</p>\n\n<pre><code>var sys = require('sys'),\n  Buffer = require('buffer').Buffer,\n  buf1 = new Buffer(26),\n  buf2 = new Buffer(26),\n  i;\n\nfor (i = 0 ; i &lt; 26 ; i += 1) {\n  buf1[i] = i + 97; // 97 is ASCII a\n  buf2[i] = 33; // ASCII !\n}\n\nbuf1.copy(buf2, 8, 16, 20);\nsys.puts(buf2.toString('ascii', 0, 25));\n\n// !!!!!!!!qrst!!!!!!!!!!!!!\n</code></pre>\n\n<h3>buffer.slice(start, end)</h3>\n\n<p>Returns a new buffer which references the\nsame memory as the old, but offset and cropped by the <code>start</code> and <code>end</code>\nindexes.</p>\n\n<p><strong>Modifying the new buffer slice will modify memory in the original buffer!</strong></p>\n\n<p>Example: build a Buffer with the ASCII alphabet, take a slice, then modify one byte\nfrom the original Buffer.</p>\n\n<pre><code>var sys = require('sys'),\n  Buffer = require('buffer').Buffer,\n  buf1 = new Buffer(26), buf2,\n  i;\n\nfor (i = 0 ; i &lt; 26 ; i += 1) {\n  buf1[i] = i + 97; // 97 is ASCII a\n}\n\nbuf2 = buf1.slice(0, 3);\nsys.puts(buf2.toString('ascii', 0, buf2.length));\nbuf1[0] = 33;\nsys.puts(buf2.toString('ascii', 0, buf2.length));\n\n// abc\n// !bc\n</code></pre>\n\n<h2 id=EventEmitter>EventEmitter</h2>\n\n<p>Many objects in Node emit events: a TCP server emits an event each time\nthere is a stream, a child process emits an event when it exits. All\nobjects which emit events are instances of <code>events.EventEmitter</code>.</p>\n\n<p>Events are represented by a camel-cased string. Here are some examples:\n<code>'stream'</code>, <code>'data'</code>, <code>'messageBegin'</code>.</p>\n\n<p>Functions can be then be attached to objects, to be executed when an event\nis emitted. These functions are called <em>listeners</em>.</p>\n\n<p><code>require('events').EventEmitter</code> to access the <code>EventEmitter</code> class.</p>\n\n<p>All EventEmitters emit the event <code>'newListener'</code> when new listeners are\nadded.</p>\n\n<p>When an EventEmitter experiences an error, the typical action is to emit an\n<code>'error'</code> event.  Error events are special--if there is no handler for them\nthey will print a stack trace and exit the program.</p>\n\n<h3>Event: 'newListener'</h3>\n\n<p><code>function (event, listener) { }</code></p>\n\n<p>This event is made any time someone adds a new listener.</p>\n\n<h3>Event: 'error'</h3>\n\n<p><code>function (exception) { }</code></p>\n\n<p>If an error was encountered, then this event is emitted. This event is\nspecial - when there are no listeners to receive the error Node will\nterminate execution and display the exception's stack trace.</p>\n\n<h3>emitter.addListener(event, listener)</h3>\n\n<p>Adds a listener to the end of the listeners array for the specified event.</p>\n\n<pre><code>server.addListener('stream', function (stream) {\n  sys.puts('someone connected!');\n});\n</code></pre>\n\n<h3>emitter.removeListener(event, listener)</h3>\n\n<p>Remove a listener from the listener array for the specified event.\n<strong>Caution</strong>: changes array indices in the listener array behind the listener.</p>\n\n<h3>emitter.removeAllListeners(event)</h3>\n\n<p>Removes all listeners from the listener array for the specified event.</p>\n\n<h3>emitter.listeners(event)</h3>\n\n<p>Returns an array of listeners for the specified event. This array can be\nmanipulated, e.g. to remove listeners.</p>\n\n<h3>emitter.emit(event, arg1, arg2, ...)</h3>\n\n<p>Execute each of the listeners in order with the supplied arguments.</p>\n\n<h2 id=Streams>Streams</h2>\n\n<p>A stream is an abstract interface implemented by various objects in Node.\nFor example a request to an HTTP server is a stream, as is stdout. Streams\nare readable, writable, or both. All streams are instances of <code>EventEmitter</code>.</p>\n\n<h2 id=\"Readable Stream\">Readable Stream</h2>\n\n<p>A <strong>readable stream</strong> has the following methods, members, and events.</p>\n\n<h3>Event: 'data'</h3>\n\n<p><code>function (data) { }</code></p>\n\n<p>The <code>'data'</code> event emits either a <code>Buffer</code> (by default) or a string if\n<code>setEncoding()</code> was used.</p>\n\n<h3>Event: 'end'</h3>\n\n<p><code>function () { }</code></p>\n\n<p>Emitted when the stream has received an EOF (FIN in TCP terminology).\nIndicates that no more <code>'data'</code> events will happen. If the stream is also\nwritable, it may be possible to continue writing.</p>\n\n<h3>Event: 'error'</h3>\n\n<p><code>function (exception) { }</code></p>\n\n<p>Emitted if there was an error receiving data.</p>\n\n<h3>Event: 'close'</h3>\n\n<p><code>function () { }</code></p>\n\n<p>Emitted when the underlying file descriptor has be closed. Not all streams\nwill emit this.  (For example, an incoming HTTP request will not emit\n<code>'close'</code>.)</p>\n\n<h3>stream.setEncoding(encoding)</h3>\n\n<p>Makes the data event emit a string instead of a <code>Buffer</code>. <code>encoding</code> can be\n<code>'utf8'</code>, <code>'ascii'</code>, or <code>'binary'</code>.</p>\n\n<h3>stream.pause()</h3>\n\n<p>Pauses the incoming <code>'data'</code> events.</p>\n\n<h3>stream.resume()</h3>\n\n<p>Resumes the incoming <code>'data'</code> events after a <code>pause()</code>.</p>\n\n<h3>stream.destroy()</h3>\n\n<p>Closes the underlying file descriptor. Stream will not emit any more events.</p>\n\n<h2 id=\"Writable Stream\">Writable Stream</h2>\n\n<p>A <strong>writable stream</strong> has the following methods, members, and events.</p>\n\n<h3>Event: 'drain'</h3>\n\n<p><code>function () { }</code></p>\n\n<p>Emitted after a <code>write()</code> method was called that returned <code>false</code> to\nindicate that it is safe to write again.</p>\n\n<h3>Event: 'error'</h3>\n\n<p><code>function (exception) { }</code></p>\n\n<p>Emitted on error with the exception <code>exception</code>.</p>\n\n<h3>Event: 'close'</h3>\n\n<p><code>function () { }</code></p>\n\n<p>Emitted when the underlying file descriptor has been closed.</p>\n\n<h3>stream.write(string, encoding)</h3>\n\n<p>Writes <code>string</code> with the given <code>encoding</code> to the stream.  Returns <code>true</code> if\nthe string has been flushed to the kernel buffer.  Returns <code>false</code> to\nindicate that the kernel buffer is full, and the data will be sent out in\nthe future. The <code>'drain'</code> event will indicate when the kernel buffer is\nempty again. The <code>encoding</code> defaults to <code>'utf8'</code>.</p>\n\n<h3>stream.write(buffer)</h3>\n\n<p>Same as the above except with a raw buffer.</p>\n\n<h3>stream.end()</h3>\n\n<p>Terminates the stream with EOF or FIN.</p>\n\n<h3>stream.end(string, encoding)</h3>\n\n<p>Sends <code>string</code> with the given <code>encoding</code> and terminates the stream with EOF\nor FIN. This is useful to reduce the number of packets sent.</p>\n\n<h3>stream.end(buffer)</h3>\n\n<p>Same as above but with a <code>buffer</code>.</p>\n\n<h3>stream.destroy()</h3>\n\n<p>Closes the underlying file descriptor. Stream will not emit any more events.</p>\n\n<h2 id=\"Global Objects\">Global Objects</h2>\n\n<p>These object are available in the global scope and can be accessed from anywhere.</p>\n\n<h3>global</h3>\n\n<p>The global namespace object.</p>\n\n<h3>process</h3>\n\n<p>The process object. Most stuff lives in here. See the <code>'process object'</code>\nsection.</p>\n\n<h3>require()</h3>\n\n<p>To require modules. See the <code>'Modules'</code> section.</p>\n\n<h3>require.paths</h3>\n\n<p>An array of search paths for <code>require()</code>.  This array can be modified to add custom paths.</p>\n\n<p>Example: add a new path to the beginning of the search list</p>\n\n<pre><code>var sys = require('sys');\n\nrequire.paths.unshift('/usr/local/node');\nsys.puts(require.paths);\n// /usr/local/node,/Users/mjr/.node_libraries\n</code></pre>\n\n<h3>__filename</h3>\n\n<p>The filename of the script being executed.  This is the absolute path, and not necessarily\nthe same filename passed in as a command line argument.</p>\n\n<h3>__dirname</h3>\n\n<p>The dirname of the script being executed.</p>\n\n<p>Example: running <code>node example.js</code> from <code>/Users/mjr</code></p>\n\n<pre><code>var sys = require('sys');\nsys.puts(__filename);\nsys.puts(__dirname);\n// /Users/mjr/example.js\n// /Users/mjr\n</code></pre>\n\n<h3>module</h3>\n\n<p>A reference to the current module (of type <code>process.Module</code>). In particular\n<code>module.exports</code> is the same as the <code>exports</code> object. See <code>src/process.js</code>\nfor more information.</p>\n\n<h2 id=process>process</h2>\n\n<p>The <code>process</code> object is a global object and can be accessed from anywhere.\nIt is an instance of <code>EventEmitter</code>.</p>\n\n<h3>Event: 'exit'</h3>\n\n<p><code>function () {}</code></p>\n\n<p>Emitted when the process is about to exit.  This is a good hook to perform\nconstant time checks of the module's state (like for unit tests).  The main\nevent loop will no longer be run after the 'exit' callback finishes, so\ntimers may not be scheduled.</p>\n\n<p>Example of listening for <code>exit</code>:</p>\n\n<pre><code>var sys = require('sys');\n\nprocess.addListener('exit', function () {\n  process.nextTick(function () {\n   sys.puts('This will not run');\n  });\n  sys.puts('About to exit.');\n});\n</code></pre>\n\n<h3>Event: 'uncaughtException'</h3>\n\n<p><code>function (err) { }</code></p>\n\n<p>Emitted when an exception bubbles all the way back to the event loop. If a\nlistener is added for this exception, the default action (which is to print\na stack trace and exit) will not occur.</p>\n\n<p>Example of listening for <code>uncaughtException</code>:</p>\n\n<pre><code>var sys = require('sys');\n\nprocess.addListener('uncaughtException', function (err) {\n  sys.puts('Caught exception: ' + err);\n});\n\nsetTimeout(function () {\n  sys.puts('This will still run.');\n}, 500);\n\n// Intentionally cause an exception, but don't catch it.\nnonexistentFunc();\nsys.puts('This will not run.');\n</code></pre>\n\n<p>Note that <code>uncaughtException</code> is a very crude mechanism for exception\nhandling.  Using try / catch in your program will give you more control over\nyour program's flow.  Especially for server programs that are designed to\nstay running forever, <code>uncaughtException</code> can be a useful safety mechanism.</p>\n\n<h3>Signal Events</h3>\n\n<p><code>function () {}</code></p>\n\n<p>Emitted when the processes receives a signal. See sigaction(2) for a list of\nstandard POSIX signal names such as SIGINT, SIGUSR1, etc.</p>\n\n<p>Example of listening for <code>SIGINT</code>:</p>\n\n<pre><code>var sys = require('sys'),\n    stdin = process.openStdin();\n\nprocess.addListener('SIGINT', function () {\n  sys.puts('Got SIGINT.  Press Control-D to exit.');\n});\n</code></pre>\n\n<p>An easy way to send the <code>SIGINT</code> signal is with <code>Control-C</code> in most terminal\nprograms.</p>\n\n<h3>process.stdout</h3>\n\n<p>A writable stream to <code>stdout</code>.</p>\n\n<p>Example: the definition of <code>sys.puts</code></p>\n\n<pre><code>exports.puts = function (d) {\n  process.stdout.write(d + '\\n');\n};\n</code></pre>\n\n<h3>process.openStdin()</h3>\n\n<p>Opens the standard input stream, returns a readable stream.</p>\n\n<p>Example of opening standard input and listening for both events:</p>\n\n<pre><code>var stdin = process.openStdin();\n\nstdin.setEncoding('utf8');\n\nstdin.addListener('data', function (chunk) {\n  process.stdout.write('data: ' + chunk);\n});\n\nstdin.addListener('end', function () {\n  process.stdout.write('end');\n});\n</code></pre>\n\n<h3>process.argv</h3>\n\n<p>An array containing the command line arguments.  The first element will be\n'node', the second element will be the name of the JavaScript file.  The\nnext elements will be any additional command line arguments.</p>\n\n<pre><code>// print process.argv\nvar sys = require('sys');\n\nprocess.argv.forEach(function (val, index, array) {\n  sys.puts(index + ': ' + val);\n});\n</code></pre>\n\n<p>This will generate:</p>\n\n<pre><code>$ node process-2.js one two=three four\n0: node\n1: /Users/mjr/work/node/process-2.js\n2: one\n3: two=three\n4: four\n</code></pre>\n\n<h3>process.chdir(directory)</h3>\n\n<p>Changes the current working directory of the process or throws an exception if that fails.</p>\n\n<pre><code>var sys = require('sys');\n\nsys.puts('Starting directory: ' + process.cwd());\ntry {\n  process.chdir('/tmp');\n  sys.puts('New directory: ' + process.cwd());\n}\ncatch (err) {\n  sys.puts('chdir: ' + err);\n}\n</code></pre>\n\n<h3>process.compile(code, filename)</h3>\n\n<p>Similar to <code>eval</code> except that you can specify a <code>filename</code> for better\nerror reporting and the <code>code</code> cannot see the local scope.  The value of <code>filename</code>\nwill be used as a filename if a stack trace is generated by the compiled code.</p>\n\n<p>Example of using <code>process.compile</code> and <code>eval</code> to run the same code:</p>\n\n<pre><code>var sys = require('sys'),\n    localVar = 123,\n    compiled, evaled;\n\ncompiled = process.compile('localVar = 1;', 'myfile.js');\nsys.puts('localVar: ' + localVar + ', compiled: ' + compiled);\nevaled = eval('localVar = 1;');\nsys.puts('localVar: ' + localVar + ', evaled: ' + evaled);\n\n// localVar: 123, compiled: 1\n// localVar: 1, evaled: 1\n</code></pre>\n\n<p><code>process.compile</code> does not have access to the local scope, so <code>localVar</code> is unchanged.\n<code>eval</code> does have access to the local scope, so <code>localVar</code> is changed.</p>\n\n<p>In case of syntax error in <code>code</code>, <code>process.compile</code> exits node.</p>\n\n<p>See also: <code>Script</code></p>\n\n<h3>process.cwd()</h3>\n\n<p>Returns the current working directory of the process.</p>\n\n<pre><code>require('sys').puts('Current directory: ' + process.cwd());\n</code></pre>\n\n<h3>process.env</h3>\n\n<p>An object containing the user environment. See environ(7).</p>\n\n<h3>process.exit(code)</h3>\n\n<p>Ends the process with the specified <code>code</code>.  If omitted, exit uses the\n'success' code <code>0</code>.</p>\n\n<p>To exit with a 'failure' code:</p>\n\n<pre><code>process.exit(1);\n</code></pre>\n\n<p>The shell that executed node should see the exit code as 1.</p>\n\n<h3>process.getgid(), process.setgid(id)</h3>\n\n<p>Gets/sets the group identity of the process. (See setgid(2).)  This is the numerical group id, not the group name.</p>\n\n<pre><code>var sys = require('sys');\n\nsys.puts('Current gid: ' + process.getgid());\ntry {\n  process.setgid(501);\n  sys.puts('New gid: ' + process.getgid());\n}\ncatch (err) {\n  sys.puts('Failed to set gid: ' + err);\n}\n</code></pre>\n\n<h3>process.getuid(), process.setuid(id)</h3>\n\n<p>Gets/sets the user identity of the process. (See setuid(2).)  This is the numerical userid, not the username.</p>\n\n<pre><code>var sys = require('sys');\n\nsys.puts('Current uid: ' + process.getuid());\ntry {\n  process.setuid(501);\n  sys.puts('New uid: ' + process.getuid());\n}\ncatch (err) {\n  sys.puts('Failed to set uid: ' + err);\n}\n</code></pre>\n\n<h3>process.version</h3>\n\n<p>A compiled-in property that exposes <code>NODE_VERSION</code>.</p>\n\n<pre><code>require('sys').puts('Version: ' + process.version);\n</code></pre>\n\n<h3>process.installPrefix</h3>\n\n<p>A compiled-in property that exposes <code>NODE_PREFIX</code>.</p>\n\n<pre><code>require('sys').puts('Prefix: ' + process.installPrefix);\n</code></pre>\n\n<h3>process.kill(pid, signal)</h3>\n\n<p>Send a signal to a process. <code>pid</code> is the process id and <code>signal</code> is the\nstring describing the signal to send.  Signal names are strings like\n'SIGINT' or 'SIGUSR1'.  If omitted, the signal will be 'SIGINT'.\nSee kill(2) for more information.</p>\n\n<p>Note that just because the name of this function is <code>process.kill</code>, it is\nreally just a signal sender, like the <code>kill</code> system call.  The signal sent\nmay do something other than kill the target process.</p>\n\n<p>Example of sending a signal to yourself:</p>\n\n<pre><code>var sys = require('sys');\n\nprocess.addListener('SIGHUP', function () {\n  sys.puts('Got SIGHUP signal.');\n});\n\nsetTimeout(function () {\n  sys.puts('Exiting.');\n  process.exit(0);\n}, 100);\n\nprocess.kill(process.pid, 'SIGHUP');\n</code></pre>\n\n<h3>process.pid</h3>\n\n<p>The PID of the process.</p>\n\n<pre><code>require('sys').puts('This process is pid ' + process.pid);\n</code></pre>\n\n<h3>process.platform</h3>\n\n<p>What platform you're running on. <code>'linux2'</code>, <code>'darwin'</code>, etc.</p>\n\n<pre><code>require('sys').puts('This platform is ' + process.platform);\n</code></pre>\n\n<h3>process.memoryUsage()</h3>\n\n<p>Returns an object describing the memory usage of the Node process.</p>\n\n<pre><code>var sys = require('sys');\n\nsys.puts(sys.inspect(process.memoryUsage()));\n</code></pre>\n\n<p>This will generate:</p>\n\n<pre><code>{ rss: 4935680\n, vsize: 41893888\n, heapTotal: 1826816\n, heapUsed: 650472\n}\n</code></pre>\n\n<p><code>heapTotal</code> and <code>heapUsed</code> refer to V8's memory usage.</p>\n\n<h3>process.nextTick(callback)</h3>\n\n<p>On the next loop around the event loop call this callback.\nThis is <em>not</em> a simple alias to <code>setTimeout(fn, 0)</code>, it's much more\nefficient.</p>\n\n<pre><code>var sys = require('sys');\n\nprocess.nextTick(function () {\n  sys.puts('nextTick callback');\n});\n</code></pre>\n\n<h3>process.umask(mask)</h3>\n\n<p>Sets or read the process's file mode creation mask. Child processes inherit\nthe mask from the parent process. Returns the old mask if <code>mask</code> argument is\ngiven, otherwise returns the current mask.</p>\n\n<pre><code>var sys = require('sys'),\n    oldmask, newmask = 0644;\n\noldmask = process.umask(newmask);\nsys.puts('Changed umask from: ' + oldmask.toString(8) +\n         ' to ' + newmask.toString(8));\n</code></pre>\n\n<h2 id=sys>sys</h2>\n\n<p>These functions are in the module <code>'sys'</code>. Use <code>require('sys')</code> to access\nthem.</p>\n\n<h3>sys.puts(string)</h3>\n\n<p>Outputs <code>string</code> and a trailing newline to <code>stdout</code>.</p>\n\n<pre><code>require('sys').puts('String with a newline');\n</code></pre>\n\n<h3>sys.print(string)</h3>\n\n<p>Like <code>puts()</code> but without the trailing newline.</p>\n\n<pre><code>require('sys').print('String with no newline');\n</code></pre>\n\n<h3>sys.debug(string)</h3>\n\n<p>A synchronous output function. Will block the process and\noutput <code>string</code> immediately to <code>stderr</code>.</p>\n\n<pre><code>require('sys').debug('message on stderr');\n</code></pre>\n\n<h3>sys.log(string)</h3>\n\n<p>Output with timestamp on <code>stdout</code>.</p>\n\n<pre><code>require('sys').log('Timestmaped message.');\n</code></pre>\n\n<h3>sys.inspect(object, showHidden, depth)</h3>\n\n<p>Return a string representation of <code>object</code>, which is useful for debugging.</p>\n\n<p>If <code>showHidden</code> is <code>true</code>, then the object's non-enumerable properties will be\nshown too.</p>\n\n<p>If <code>depth</code> is provided, it tells <code>inspect</code> how many times to recurse while\nformatting the object. This is useful for inspecting large complicated objects.</p>\n\n<p>The default is to only recurse twice.  To make it recurse indefinitely, pass\nin <code>null</code> for <code>depth</code>.</p>\n\n<p>Example of inspecting all properties of the <code>sys</code> object:</p>\n\n<pre><code>var sys = require('sys');\n\nsys.puts(sys.inspect(sys, true, null));\n</code></pre>\n\n<h2 id=Timers>Timers</h2>\n\n<h3>setTimeout(callback, delay, [arg, ...])</h3>\n\n<p>To schedule execution of <code>callback</code> after <code>delay</code> milliseconds. Returns a\n<code>timeoutId</code> for possible use with <code>clearTimeout()</code>.</p>\n\n<h3>clearTimeout(timeoutId)</h3>\n\n<p>Prevents a timeout from triggering.</p>\n\n<h3>setInterval(callback, delay, [arg, ...])</h3>\n\n<p>To schedule the repeated execution of <code>callback</code> every <code>delay</code> milliseconds.\nReturns a <code>intervalId</code> for possible use with <code>clearInterval()</code>.</p>\n\n<p>Optionally, you can also pass arguments to the callback.</p>\n\n<h3>clearInterval(intervalId)</h3>\n\n<p>Stops a interval from triggering.</p>\n\n<h2 id=\"Child Processes\">Child Processes</h2>\n\n<p>Node provides a tri-directional <code>popen(3)</code> facility through the <code>ChildProcess</code>\nclass.</p>\n\n<p>It is possible to stream data through the child's <code>stdin</code>, <code>stdout</code>, and\n<code>stderr</code> in a fully non-blocking way.</p>\n\n<p>To create a child process use <code>require('child_process').spawn()</code>.</p>\n\n<p>Child processes always have three streams associated with them. <code>child.stdin</code>,\n<code>child.stdout</code>, and <code>child.stderr</code>.</p>\n\n<p><code>ChildProcess</code> is an EventEmitter.</p>\n\n<h3>Event:  'exit'</h3>\n\n<p><code>function (code, signal) {}</code></p>\n\n<p>This event is emitted after the child process ends. If the process terminated\nnormally, <code>code</code> is the final exit code of the process, otherwise <code>null</code>. If\nthe process terminated due to receipt of a signal, <code>signal</code> is the string name\nof the signal, otherwise <code>null</code>.</p>\n\n<p>After this event is emitted, the <code>'output'</code> and <code>'error'</code> callbacks will no\nlonger be made.</p>\n\n<p>See <code>waitpid(2)</code>.</p>\n\n<h3>child_process.spawn(command, args, env)</h3>\n\n<p>Launches a new process with the given <code>command</code>, command line arguments, and\nenvironment variables.  If omitted, <code>args</code> defaults to an empty Array, and <code>env</code>\ndefaults to <code>process.env</code>.</p>\n\n<p>Example of running <code>ls -lh /usr</code>, capturing <code>stdout</code>, <code>stderr</code>, and the exit code:</p>\n\n<pre><code>var sys   = require('sys'),\n    spawn = require('child_process').spawn,\n    ls    = spawn('ls', ['-lh', '/usr']);\n\nls.stdout.addListener('data', function (data) {\n  sys.print('stdout: ' + data);\n});\n\nls.stderr.addListener('data', function (data) {\n  sys.print('stderr: ' + data);\n});\n\nls.addListener('exit', function (code) {\n  sys.puts('child process exited with code ' + code);\n});\n</code></pre>\n\n<p>Example of checking for failed exec:</p>\n\n<pre><code>var sys   = require('sys'),\n    spawn = require('child_process').spawn,\n    child = spawn('bad_command');\n\nchild.stderr.addListener('data', function (data) {\n  if (/^execvp\\(\\)/.test(data.asciiSlice(0,data.length))) {\n    sys.puts('Failed to start child process.');\n  }\n});\n</code></pre>\n\n<p>See also: <code>child_process.exec()</code></p>\n\n<h3>child.kill(signal)</h3>\n\n<p>Send a signal to the child process. If no argument is given, the process will\nbe sent <code>'SIGTERM'</code>. See <code>signal(7)</code> for a list of available signals.</p>\n\n<pre><code>var sys   = require('sys'),\n    spawn = require('child_process').spawn,\n    grep  = spawn('grep', ['ssh']);\n\ngrep.addListener('exit', function (code, signal) {\n  sys.puts('child process terminated due to receipt of signal '+signal);\n});\n\n// send SIGHUP to process\ngrep.kill('SIGHUP');\n</code></pre>\n\n<p>Note that while the function is called <code>kill</code>, the signal delivered to the child\nprocess may not actually kill it.  <code>kill</code> really just sends a signal to a process.</p>\n\n<p>See <code>kill(2)</code></p>\n\n<h3>child.pid</h3>\n\n<p>The PID of the child process.</p>\n\n<p>Example:</p>\n\n<pre><code>var sys   = require('sys'),\n    spawn = require('child_process').spawn,\n    grep  = spawn('grep', ['ssh']);\n\nsys.puts('Spawned child pid: ' + grep.pid);\ngrep.stdin.end();\n</code></pre>\n\n<h3>child.stdin.write(data, encoding)</h3>\n\n<p>Write data to the child process's <code>stdin</code>. The second argument is optional and\nspecifies the encoding: possible values are <code>'utf8'</code>, <code>'ascii'</code>, and\n<code>'binary'</code>.</p>\n\n<p>Example: A very elaborate way to run 'ps ax | grep ssh'</p>\n\n<pre><code>var sys   = require('sys'),\n    spawn = require('child_process').spawn,\n    ps    = spawn('ps', ['ax']),\n    grep  = spawn('grep', ['ssh']);\n\nps.stdout.addListener('data', function (data) {\n  grep.stdin.write(data);\n});\n\nps.stderr.addListener('data', function (data) {\n  sys.print('ps stderr: ' + data);\n});\n\nps.addListener('exit', function (code) {\n  if (code !== 0) {\n    sys.puts('ps process exited with code ' + code);\n  }\n  grep.stdin.end();\n});\n\ngrep.stdout.addListener('data', function (data) {\n  sys.print(data);\n});\n\ngrep.stderr.addListener('data', function (data) {\n  sys.print('grep stderr: ' + data);\n});\n\ngrep.addListener('exit', function (code) {\n  if (code !== 0) {\n    sys.puts('grep process exited with code ' + code);\n  }\n});\n</code></pre>\n\n<h3>child.stdin.end()</h3>\n\n<p>Closes the child process's <code>stdin</code> stream.  This often causes the child process to terminate.</p>\n\n<p>Example:</p>\n\n<pre><code>var sys   = require('sys'),\n    spawn = require('child_process').spawn,\n    grep  = spawn('grep', ['ssh']);\n\ngrep.addListener('exit', function (code) {\n  sys.puts('child process exited with code ' + code);\n});\n\ngrep.stdin.end();\n</code></pre>\n\n<h3>child_process.exec(command, [options, ] callback)</h3>\n\n<p>High-level way to execute a command as a child process, buffer the\noutput, and return it all in a callback.</p>\n\n<pre><code>var sys   = require('sys'),\n    exec  = require('child_process').exec,\n    child;\n\nchild = exec('cat *.js bad_file | wc -l', \n  function (error, stdout, stderr) {\n    sys.print('stdout: ' + stdout);\n    sys.print('stderr: ' + stderr);\n    if (error !== null) {\n      sys.puts('exec error: ' + error);\n    }\n  });\n</code></pre>\n\n<p>The callback gets the arguments <code>(error, stdout, stderr)</code>. On success, <code>error</code>\nwill be <code>null</code>.  On error, <code>error</code> will be an instance of <code>Error</code> and <code>err.code</code>\nwill be the exit code of the child process, and <code>err.signal</code> will be set to the\nsignal that terminated the process.</p>\n\n<p>There is a second optional argument to specify several options. The default options are</p>\n\n<pre><code>{ encoding: 'utf8'\n, timeout: 0\n, maxBuffer: 200*1024\n, killSignal: 'SIGKILL'\n}\n</code></pre>\n\n<p>If <code>timeout</code> is greater than 0, then it will kill the child process\nif it runs longer than <code>timeout</code> milliseconds. The child process is killed with\n<code>killSignal</code> (default: <code>'SIGKILL'</code>). <code>maxBuffer</code> specifies the largest\namount of data allowed on stdout or stderr - if this value is exceeded then\nthe child process is killed.</p>\n\n<h2 id=Script>Script</h2>\n\n<p><code>Script</code> class compiles and runs JavaScript code. You can access this class with:</p>\n\n<pre><code>var Script = process.binding('evals').Script;\n</code></pre>\n\n<p>New JavaScript code can be compiled and run immediately or compiled, saved, and run later.</p>\n\n<h3>Script.runInThisContext(code, filename)</h3>\n\n<p>Similar to <code>process.compile</code>.  <code>Script.runInThisContext</code> compiles <code>code</code> as if it were loaded from <code>filename</code>,\nruns it and returns the result. Running code does not have access to local scope. <code>filename</code> is optional.</p>\n\n<p>Example of using <code>Script.runInThisContext</code> and <code>eval</code> to run the same code:</p>\n\n<pre><code>var sys = require('sys'),\n    localVar = 123,\n    usingscript, evaled,\n    Script = process.binding('evals').Script;\n\nusingscript = Script.runInThisContext('localVar = 1;',\n  'myfile.js');\nsys.puts('localVar: ' + localVar + ', usingscript: ' +\n  usingscript);\nevaled = eval('localVar = 1;');\nsys.puts('localVar: ' + localVar + ', evaled: ' +\n  evaled);\n\n// localVar: 123, usingscript: 1\n// localVar: 1, evaled: 1\n</code></pre>\n\n<p><code>Script.runInThisContext</code> does not have access to the local scope, so <code>localVar</code> is unchanged.\n<code>eval</code> does have access to the local scope, so <code>localVar</code> is changed.</p>\n\n<p>In case of syntax error in <code>code</code>, <code>Script.runInThisContext</code> emits the syntax error to stderr\nand throws.an exception.</p>\n\n<h3>Script.runInNewContext(code, sandbox, filename)</h3>\n\n<p><code>Script.runInNewContext</code> compiles <code>code</code> to run in <code>sandbox</code> as if it were loaded from <code>filename</code>,\nthen runs it and returns the result. Running code does not have access to local scope and\nthe object <code>sandbox</code> will be used as the global object for <code>code</code>.\n<code>sandbox</code> and <code>filename</code> are optional.</p>\n\n<p>Example: compile and execute code that increments a global variable and sets a new one.\nThese globals are contained in the sandbox.</p>\n\n<pre><code>var sys = require('sys'),\n    Script = process.binding('evals').Script,\n    sandbox = {\n      animal: 'cat',\n      count: 2\n    };\n\nScript.runInNewContext(\n  'count += 1; name = \"kitty\"', sandbox, 'myfile.js');\nsys.puts(sys.inspect(sandbox));\n\n// { animal: 'cat', count: 3, name: 'kitty' }\n</code></pre>\n\n<p>Note that running untrusted code is a tricky business requiring great care.  To prevent accidental\nglobal variable leakage, <code>Script.runInNewContext</code> is quite useful, but safely running untrusted code\nrequires a separate process.</p>\n\n<p>In case of syntax error in <code>code</code>, <code>Script.runInThisContext</code> emits the syntax error to stderr\nand throws an exception.</p>\n\n<h3>new Script(code, filename)</h3>\n\n<p><code>new Script</code> compiles <code>code</code> as if it were loaded from <code>filename</code>,\nbut does not run it. Instead, it returns a <code>Script</code> object representing this compiled code.\nThis script can be run later many times using methods below.\nThe returned script is not bound to any global object.\nIt is bound before each run, just for that run. <code>filename</code> is optional.</p>\n\n<p>In case of syntax error in <code>code</code>, <code>new Script</code> emits the syntax error to stderr\nand throws an exception.</p>\n\n<h3>script.runInThisContext()</h3>\n\n<p>Similar to <code>Script.runInThisContext</code> (note capital 'S'), but now being a method of a precompiled Script object.\n<code>script.runInThisContext</code> runs the code of <code>script</code> and returns the result.\nRunning code does not have access to local scope, but does have access to the <code>global</code> object\n(v8: in actual context).</p>\n\n<p>Example of using <code>script.runInThisContext</code> to compile code once and run it multiple times:</p>\n\n<pre><code>var sys = require('sys'),\n    Script = process.binding('evals').Script,\n    scriptObj, i;\n\nglobalVar = 0;\n\nscriptObj = new Script('globalVar += 1', 'myfile.js');\n\nfor (i = 0; i &lt; 1000 ; i += 1) {\n  scriptObj.runInThisContext();\n}\n\nsys.puts(globalVar);\n\n// 1000\n</code></pre>\n\n<h3>script.runInNewContext(sandbox)</h3>\n\n<p>Similar to <code>Script.runInNewContext</code> (note capital 'S'), but now being a method of a precompiled Script object.\n<code>script.runInNewContext</code> runs the code of <code>script</code> with <code>sandbox</code> as the global object and returns the result.\nRunning code does not have access to local scope. <code>sandbox</code> is optional.</p>\n\n<p>Example: compile code that increments a global variable and sets one, then execute this code multiple times.\nThese globals are contained in the sandbox.</p>\n\n<pre><code>var sys = require('sys'),\n    Script = process.binding('evals').Script,\n    scriptObj, i,\n    sandbox = {\n      animal: 'cat',\n      count: 2\n    };\n\nscriptObj = new Script(\n    'count += 1; name = \"kitty\"', 'myfile.js');\n\nfor (i = 0; i &lt; 10 ; i += 1) {\n  scriptObj.runInNewContext(sandbox);\n}\n\nsys.puts(sys.inspect(sandbox));\n\n// { animal: 'cat', count: 12, name: 'kitty' }\n</code></pre>\n\n<p>Note that running untrusted code is a tricky business requiring great care.  To prevent accidental\nglobal variable leakage, <code>script.runInNewContext</code> is quite useful, but safely running untrusted code\nrequires a separate process.</p>\n\n<h2 id=\"File System\">File System</h2>\n\n<p>File I/O is provided by simple wrappers around standard POSIX functions.  To\nuse this module do <code>require('fs')</code>. All the methods have asynchronous and\nsynchronous forms.</p>\n\n<p>The asynchronous form always take a completion callback as its last argument.\nThe arguments passed to the completion callback depend on the method, but the\nfirst argument is always reserved for an exception. If the operation was\ncompleted successfully, then the first argument will be <code>null</code> or <code>undefined</code>.</p>\n\n<p>Here is an example of the asynchronous version:</p>\n\n<pre><code>var fs = require('fs'),\n    sys = require('sys');\n\nfs.unlink('/tmp/hello', function (err) {\n  if (err) throw err;\n  sys.puts('successfully deleted /tmp/hello');\n});\n</code></pre>\n\n<p>Here is the synchronous version:</p>\n\n<pre><code>var fs = require('fs'),\n    sys = require('sys');\n\nfs.unlinkSync('/tmp/hello')\nsys.puts('successfully deleted /tmp/hello');\n</code></pre>\n\n<p>With the asynchronous methods there is no guaranteed ordering. So the\nfollowing is prone to error:</p>\n\n<pre><code>fs.rename('/tmp/hello', '/tmp/world', function (err) {\n  if (err) throw err;\n  sys.puts('renamed complete');\n});\nfs.stat('/tmp/world', function (err, stats) {\n  if (err) throw err;\n  sys.puts('stats: ' + JSON.stringify(stats));\n});\n</code></pre>\n\n<p>It could be that <code>fs.stat</code> is executed before <code>fs.rename</code>.\nThe correct way to do this is to chain the callbacks.</p>\n\n<pre><code>fs.rename('/tmp/hello', '/tmp/world', function (err) {\n  if (err) throw err;\n  fs.stat('/tmp/world', function (err, stats) {\n    if (err) throw err;\n    sys.puts('stats: ' + JSON.stringify(stats));\n  });\n});\n</code></pre>\n\n<p>In busy processes, the programmer is <em>strongly encouraged</em> to use the\nasynchronous versions of these calls. The synchronous versions will block\nthe entire process until they complete--halting all connections.</p>\n\n<h3>fs.rename(path1, path2, callback)</h3>\n\n<p>Asynchronous rename(2). No arguments other than a possible exception are given to the completion callback.</p>\n\n<h3>fs.renameSync(path1, path2)</h3>\n\n<p>Synchronous rename(2).</p>\n\n<h3>fs.truncate(fd, len, callback)</h3>\n\n<p>Asynchronous ftruncate(2). No arguments other than a possible exception are given to the completion callback.</p>\n\n<h3>fs.truncateSync(fd, len)</h3>\n\n<p>Synchronous ftruncate(2).</p>\n\n<h3>fs.chmod(path, mode, callback)</h3>\n\n<p>Asynchronous chmod(2). No arguments other than a possible exception are given to the completion callback.</p>\n\n<h3>fs.chmodSync(path, mode)</h3>\n\n<p>Synchronous chmod(2).</p>\n\n<h3>fs.stat(path, callback), fs.lstat(path, callback), fs.fstat(fd, callback)</h3>\n\n<p>Asynchronous stat(2), lstat(2) or fstat(2). The callback gets two arguments <code>(err, stats)</code> where <code>stats</code> is a <code>fs.Stats</code> object. It looks like this:</p>\n\n<pre><code>{ dev: 2049\n, ino: 305352\n, mode: 16877\n, nlink: 12\n, uid: 1000\n, gid: 1000\n, rdev: 0\n, size: 4096\n, blksize: 4096\n, blocks: 8\n, atime: '2009-06-29T11:11:55Z'\n, mtime: '2009-06-29T11:11:40Z'\n, ctime: '2009-06-29T11:11:40Z' \n}\n</code></pre>\n\n<p>See the <code>fs.Stats</code> section below for more information.</p>\n\n<h3>fs.statSync(path), fs.lstatSync(path), fs.fstatSync(fd)</h3>\n\n<p>Synchronous stat(2), lstat(2) or fstat(2). Returns an instance of <code>fs.Stats</code>.</p>\n\n<h3>fs.link(srcpath, dstpath, callback)</h3>\n\n<p>Asynchronous link(2). No arguments other than a possible exception are given to the completion callback.</p>\n\n<h3>fs.linkSync(dstpath, srcpath)</h3>\n\n<p>Synchronous link(2).</p>\n\n<h3>fs.symlink(linkdata, path, callback)</h3>\n\n<p>Asynchronous symlink(2). No arguments other than a possible exception are given to the completion callback.</p>\n\n<h3>fs.symlinkSync(linkdata, path)</h3>\n\n<p>Synchronous symlink(2).</p>\n\n<h3>fs.readlink(path, callback)</h3>\n\n<p>Asynchronous readlink(2). The callback gets two arguments <code>(err, resolvedPath)</code>.</p>\n\n<h3>fs.readlinkSync(path)</h3>\n\n<p>Synchronous readlink(2). Returns the resolved path.</p>\n\n<h3>fs.realpath(path, callback)</h3>\n\n<p>Asynchronous realpath(2).  The callback gets two arguments <code>(err, resolvedPath)</code>.</p>\n\n<h3>fs.realpathSync(path)</h3>\n\n<p>Synchronous realpath(2). Returns the resolved path.</p>\n\n<h3>fs.unlink(path, callback)</h3>\n\n<p>Asynchronous unlink(2). No arguments other than a possible exception are given to the completion callback.</p>\n\n<h3>fs.unlinkSync(path)</h3>\n\n<p>Synchronous unlink(2).</p>\n\n<h3>fs.rmdir(path, callback)</h3>\n\n<p>Asynchronous rmdir(2). No arguments other than a possible exception are given to the completion callback.</p>\n\n<h3>fs.rmdirSync(path)</h3>\n\n<p>Synchronous rmdir(2).</p>\n\n<h3>fs.mkdir(path, mode, callback)</h3>\n\n<p>Asynchronous mkdir(2). No arguments other than a possible exception are given to the completion callback.</p>\n\n<h3>fs.mkdirSync(path, mode)</h3>\n\n<p>Synchronous mkdir(2).</p>\n\n<h3>fs.readdir(path, callback)</h3>\n\n<p>Asynchronous readdir(3).  Reads the contents of a directory.\nThe callback gets two arguments <code>(err, files)</code> where <code>files</code> is an array of\nthe names of the files in the directory excluding <code>'.'</code> and <code>'..'</code>.</p>\n\n<h3>fs.readdirSync(path)</h3>\n\n<p>Synchronous readdir(3). Returns an array of filenames excluding <code>'.'</code> and\n<code>'..'</code>.</p>\n\n<h3>fs.close(fd, callback)</h3>\n\n<p>Asynchronous close(2).  No arguments other than a possible exception are given to the completion callback.</p>\n\n<h3>fs.closeSync(fd)</h3>\n\n<p>Synchronous close(2).</p>\n\n<h3>fs.open(path, flags, mode, callback)</h3>\n\n<p>Asynchronous file open. See open(2). Flags can be 'r', 'r+', 'w', 'w+', 'a',\nor 'a+'. The callback gets two arguments <code>(err, fd)</code>.</p>\n\n<h3>fs.openSync(path, flags, mode)</h3>\n\n<p>Synchronous open(2).</p>\n\n<h3>fs.write(fd, buffer, offset, length, position, callback)</h3>\n\n<p>Write <code>buffer</code> to the file specified by <code>fd</code>.</p>\n\n<p><code>offset</code> and <code>length</code> determine the part of the buffer to be written.</p>\n\n<p><code>position</code> refers to the offset from the beginning of the file where this data\nshould be written. If <code>position</code> is <code>null</code>, the data will be written at the\ncurrent position.\nSee pwrite(2).</p>\n\n<p>The callback will be given two arguments <code>(err, written)</code> where <code>written</code>\nspecifies how many <em>bytes</em> were written.</p>\n\n<h3>fs.writeSync(fd, data, position, encoding)</h3>\n\n<p>Synchronous version of <code>fs.write()</code>. Returns the number of bytes written.</p>\n\n<h3>fs.read(fd, buffer, offset, length, position, callback)</h3>\n\n<p>Read data from the file specified by <code>fd</code>.</p>\n\n<p><code>buffer</code> is the buffer that the data will be written to.</p>\n\n<p><code>offset</code> is offset within the buffer where writing will start.</p>\n\n<p><code>length</code> is an integer specifying the number of bytes to read.</p>\n\n<p><code>position</code> is an integer specifying where to begin reading from in the file.\nIf <code>position</code> is <code>null</code>, data will be read from the current file position.</p>\n\n<p>The callback is given the two arguments, <code>(err, bytesRead)</code>.</p>\n\n<h3>fs.readSync(fd, buffer, offset, length, position)</h3>\n\n<p>Synchronous version of <code>fs.read</code>. Returns the number of <code>bytesRead</code>.</p>\n\n<h3>fs.readFile(filename, [encoding,] callback)</h3>\n\n<p>Asynchronously reads the entire contents of a file. Example:</p>\n\n<pre><code>fs.readFile('/etc/passwd', function (err, data) {\n  if (err) throw err;\n  sys.puts(data);\n});\n</code></pre>\n\n<p>The callback is passed two arguments <code>(err, data)</code>, where <code>data</code> is the\ncontents of the file.</p>\n\n<p>If no encoding is specified, then the raw buffer is returned.</p>\n\n<h3>fs.readFileSync(filename [, encoding])</h3>\n\n<p>Synchronous version of <code>fs.readFile</code>. Returns the contents of the <code>filename</code>.</p>\n\n<p>If <code>encoding</code> is specified then this function returns a string. Otherwise it\nreturns a buffer.</p>\n\n<h3>fs.writeFile(filename, data, encoding='utf8', callback)</h3>\n\n<p>Asynchronously writes data to a file. Example:</p>\n\n<pre><code>fs.writeFile('message.txt', 'Hello Node', function (err) {\n  if (err) throw err;\n  sys.puts('It\\'s saved!');\n});\n</code></pre>\n\n<h3>fs.writeFileSync(filename, data, encoding='utf8')</h3>\n\n<p>The synchronous version of <code>fs.writeFile</code>.</p>\n\n<h3>fs.watchFile(filename, [options,] listener)</h3>\n\n<p>Watch for changes on <code>filename</code>. The callback <code>listener</code> will be called each\ntime the file changes.</p>\n\n<p>The second argument is optional. The <code>options</code> if provided should be an object\ncontaining two members a boolean, <code>persistent</code>, and <code>interval</code>, a polling\nvalue in milliseconds. The default is <code>{persistent: true, interval: 0}</code>.</p>\n\n<p>The <code>listener</code> gets two arguments the current stat object and the previous\nstat object:</p>\n\n<pre><code>fs.watchFile(f, function (curr, prev) {\n  sys.puts('the current mtime is: ' + curr.mtime);\n  sys.puts('the previous mtime was: ' + prev.mtime);\n});\n</code></pre>\n\n<p>These stat objects are instances of <code>fs.Stat</code>.</p>\n\n<h3>fs.unwatchFile(filename)</h3>\n\n<p>Stop watching for changes on <code>filename</code>.</p>\n\n<h2 id=fs.Stats>fs.Stats</h2>\n\n<p>Objects returned from <code>fs.stat()</code> and <code>fs.lstat()</code> are of this type.</p>\n\n<ul>\n<li><code>stats.isFile()</code></li>\n<li><code>stats.isDirectory()</code></li>\n<li><code>stats.isBlockDevice()</code></li>\n<li><code>stats.isCharacterDevice()</code></li>\n<li><code>stats.isSymbolicLink()</code> (only valid with  <code>fs.lstat()</code>)</li>\n<li><code>stats.isFIFO()</code></li>\n<li><code>stats.isSocket()</code></li>\n</ul>\n\n\n<h2 id=fs.ReadStream>fs.ReadStream</h2>\n\n<p><code>ReadStream</code> is a readable stream.</p>\n\n<h3>fs.createReadStream(path, [options])</h3>\n\n<p>Returns a new ReadStream object.</p>\n\n<p><code>options</code> is an object with the following defaults:</p>\n\n<pre><code>{ 'flags': 'r'\n, 'encoding': 'binary'\n, 'mode': 0666\n, 'bufferSize': 4 * 1024\n}\n</code></pre>\n\n<h3>readStream.readable</h3>\n\n<p>A boolean that is <code>true</code> by default, but turns <code>false</code> after an <code>'error'</code>\noccured, the stream came to an <code>'end'</code>, or <code>destroy()</code> was called.</p>\n\n<h3>readStream.pause()</h3>\n\n<p>Stops the stream from reading further data. No <code>'data'</code> event will be fired\nuntil the stream is resumed.</p>\n\n<h3>readStream.resume()</h3>\n\n<p>Resumes the stream. Together with <code>pause()</code> this useful to throttle reading.</p>\n\n<h3>readStream.destroy()</h3>\n\n<p>Allows to close the stream before the <code>'end'</code> is reached. No more events other\nthan <code>'close'</code> will be fired after this method has been called.</p>\n\n<h2 id=fs.WriteStream>fs.WriteStream</h2>\n\n<p><code>WriteStream</code> is a writable stream.</p>\n\n<h3>fs.createWriteStream(path, [options])</h3>\n\n<p>Returns a new WriteStream object.\n<code>options</code> is an object with the following defaults:</p>\n\n<pre><code>{ 'flags': 'w'\n, 'encoding': 'binary'\n, 'mode': 0666\n}\n</code></pre>\n\n<h3>writeStream.writeable</h3>\n\n<p>A boolean that is <code>true</code> by default, but turns <code>false</code> after an <code>'error'</code>\noccurred or <code>end()</code> / <code>destroy()</code> was called.</p>\n\n<h3>writeStream.write(data, encoding='utf8')</h3>\n\n<p>Returns <code>true</code> if the data was flushed to the kernel, and <code>false</code> if it was\nqueued up for being written later. A <code>'drain'</code> will fire after all queued data\nhas been written.</p>\n\n<p>The second optional parameter specifies the encoding of for the string.</p>\n\n<h3>writeStream.end()</h3>\n\n<p>Closes the stream right after all queued <code>write()</code> calls have finished.</p>\n\n<h3>writeStream.destroy()</h3>\n\n<p>Allows to close the stream regardless of its current state.</p>\n\n<h2 id=HTTP>HTTP</h2>\n\n<p>To use the HTTP server and client one must <code>require('http')</code>.</p>\n\n<p>The HTTP interfaces in Node are designed to support many features\nof the protocol which have been traditionally difficult to use.\nIn particular, large, possibly chunk-encoded, messages. The interface is\ncareful to never buffer entire requests or responses--the\nuser is able to stream data.</p>\n\n<p>HTTP message headers are represented by an object like this:</p>\n\n<pre><code>{ 'content-length': '123'\n, 'content-type': 'text/plain'\n, 'stream': 'keep-alive'\n, 'accept': '*/*'\n}\n</code></pre>\n\n<p>Keys are lowercased. Values are not modified.</p>\n\n<p>In order to support the full spectrum of possible HTTP applications, Node's\nHTTP API is very low-level. It deals with stream handling and message\nparsing only. It parses a message into headers and body but it does not\nparse the actual headers or the body.</p>\n\n<p>HTTPS is supported if OpenSSL is available on the underlying platform.</p>\n\n<h2 id=http.Server>http.Server</h2>\n\n<p>This is an EventEmitter with the following events:</p>\n\n<h3>Event: 'request'</h3>\n\n<p><code>function (request, response) { }</code></p>\n\n<p> <code>request</code> is an instance of <code>http.ServerRequest</code> and <code>response</code> is\n an instance of <code>http.ServerResponse</code></p>\n\n<h3>Event: 'connection'</h3>\n\n<p><code>function (stream) { }</code></p>\n\n<p> When a new TCP stream is established. <code>stream</code> is an object of type\n <code>net.Stream</code>. Usually users will not want to access this event. The\n <code>stream</code> can also be accessed at <code>request.connection</code>.</p>\n\n<h3>Event: 'close'</h3>\n\n<p><code>function (errno) { }</code></p>\n\n<p> Emitted when the server closes.</p>\n\n<h3>http.createServer(requestListener, [options])</h3>\n\n<p>Returns a new web server object.</p>\n\n<p>The <code>options</code> argument is optional. The\n<code>options</code> argument accepts the same values as the\noptions argument for <code>net.Server</code>.</p>\n\n<p>The <code>requestListener</code> is a function which is automatically\nadded to the <code>'request'</code> event.</p>\n\n<h3>Event: 'request'</h3>\n\n<p><code>function (request, response) {}</code></p>\n\n<p>Emitted each time there is request. Note that there may be multiple requests\nper connection (in the case of keep-alive connections).</p>\n\n<h3>Event: 'upgrade'</h3>\n\n<p><code>function (request, socket, head)</code></p>\n\n<p>Emitted each time a client requests a http upgrade. If this event isn't\nlistened for, then clients requesting an upgrade will have their connections\nclosed.</p>\n\n<ul>\n<li><code>request</code> is the arguments for the http request, as it is in the request event.</li>\n<li><code>socket</code> is the network socket between the server and client.</li>\n<li><code>head</code> is an instance of Buffer, the first packet of the upgraded stream, this may be empty.</li>\n</ul>\n\n\n<p>After this event is emitted, the request's socket will not have a <code>data</code>\nevent listener, meaning you will need to bind to it in order to handle data\nsent to the server on that socket.</p>\n\n<h3>Event: 'clientError'</h3>\n\n<p><code>function (exception) {}</code></p>\n\n<p>If a client connection emits an 'error' event - it will forwarded here.</p>\n\n<h3>server.listen(port, hostname=null, callback=null)</h3>\n\n<p>Begin accepting connections on the specified port and hostname.  If the\nhostname is omitted, the server will accept connections directed to any\nIPv4 address (<code>INADDR_ANY</code>).</p>\n\n<p>To listen to a unix socket, supply a filename instead of port and hostname.</p>\n\n<p>This function is asynchronous. The last parameter <code>callback</code> will be called\nwhen the server has been bound to the port.</p>\n\n<h3>server.listen(path, callback=null)</h3>\n\n<p>Start a UNIX socket server listening for connections on the given <code>path</code>.</p>\n\n<p>This function is asynchronous. The last parameter <code>callback</code> will be called\nwhen the server has been bound.</p>\n\n<h3>server.setSecure(credentials)</h3>\n\n<p>Enables HTTPS support for the server, with the crypto module credentials specifying the private key and certificate of the server, and optionally the CA certificates for use in client authentication.</p>\n\n<p>If the credentials hold one or more CA certificates, then the server will request for the client to submit a client certificate as part of the HTTPS connection handshake. The validity and content of this can be accessed via verifyPeer() and getPeerCertificate() from the server's request.connection.</p>\n\n<h3>server.close()</h3>\n\n<p>Stops the server from accepting new connections.</p>\n\n<h2 id=http.ServerRequest>http.ServerRequest</h2>\n\n<p>This object is created internally by a HTTP server--not by\nthe user--and passed as the first argument to a <code>'request'</code> listener.</p>\n\n<p>This is an EventEmitter with the following events:</p>\n\n<h3>Event: 'data'</h3>\n\n<p><code>function (chunk) { }</code></p>\n\n<p>Emitted when a piece of the message body is received.</p>\n\n<p>Example: A chunk of the body is given as the single\nargument. The transfer-encoding has been decoded.  The\nbody chunk is a string.  The body encoding is set with\n<code>request.setBodyEncoding()</code>.</p>\n\n<h3>Event: 'end'</h3>\n\n<p><code>function () { }</code></p>\n\n<p>Emitted exactly once for each message. No arguments.  After\nemitted no other events will be emitted on the request.</p>\n\n<h3>request.method</h3>\n\n<p>The request method as a string. Read only. Example:\n<code>'GET'</code>, <code>'DELETE'</code>.</p>\n\n<h3>request.url</h3>\n\n<p>Request URL string. This contains only the URL that is\npresent in the actual HTTP request. If the request is:</p>\n\n<pre><code>GET /status?name=ryan HTTP/1.1\\r\\n\nAccept: text/plain\\r\\n\n\\r\\n\n</code></pre>\n\n<p>Then <code>request.url</code> will be:</p>\n\n<pre><code>'/status?name=ryan'\n</code></pre>\n\n<p>If you would like to parse the URL into its parts, you can use\n<code>require('url').parse(request.url)</code>.  Example:</p>\n\n<pre><code>node&gt; require('url').parse('/status?name=ryan')\n{ href: '/status?name=ryan'\n, search: '?name=ryan'\n, query: 'name=ryan'\n, pathname: '/status'\n}\n</code></pre>\n\n<p>If you would like to extract the params from the query string,\nyou can use the <code>require('querystring').parse</code> function, or pass\n<code>true</code> as the second argument to <code>require('url').parse</code>.  Example:</p>\n\n<pre><code>node&gt; require('url').parse('/status?name=ryan', true)\n{ href: '/status?name=ryan'\n, search: '?name=ryan'\n, query: { name: 'ryan' }\n, pathname: '/status'\n}\n</code></pre>\n\n<h3>request.headers</h3>\n\n<p>Read only.</p>\n\n<h3>request.httpVersion</h3>\n\n<p>The HTTP protocol version as a string. Read only. Examples:\n<code>'1.1'</code>, <code>'1.0'</code>.\nAlso <code>request.httpVersionMajor</code> is the first integer and\n<code>request.httpVersionMinor</code> is the second.</p>\n\n<h3>request.setEncoding(encoding='binary')</h3>\n\n<p>Set the encoding for the request body. Either <code>'utf8'</code> or <code>'binary'</code>. Defaults\nto <code>'binary'</code>.</p>\n\n<h3>request.pause()</h3>\n\n<p>Pauses request from emitting events.  Useful to throttle back an upload.</p>\n\n<h3>request.resume()</h3>\n\n<p>Resumes a paused request.</p>\n\n<h3>request.connection</h3>\n\n<p>The <code>net.Stream</code> object assocated with the connection.</p>\n\n<p>With HTTPS support, use request.connection.verifyPeer() and\nrequest.connection.getPeerCertificate() to obtain the client's\nauthentication details.</p>\n\n<h2 id=http.ServerResponse>http.ServerResponse</h2>\n\n<p>This object is created internally by a HTTP server--not by the user. It is\npassed as the second parameter to the <code>'request'</code> event. It is a writable stream.</p>\n\n<h3>response.writeHead(statusCode[, reasonPhrase] , headers)</h3>\n\n<p>Sends a response header to the request. The status code is a 3-digit HTTP\nstatus code, like <code>404</code>. The last argument, <code>headers</code>, are the response headers.\nOptionally one can give a human-readable <code>reasonPhrase</code> as the second\nargument.</p>\n\n<p>Example:</p>\n\n<pre><code>var body = 'hello world';\nresponse.writeHead(200, {\n  'Content-Length': body.length,\n  'Content-Type': 'text/plain'\n});\n</code></pre>\n\n<p>This method must only be called once on a message and it must\nbe called before <code>response.end()</code> is called.</p>\n\n<h3>response.write(chunk, encoding)</h3>\n\n<p>This method must be called after <code>writeHead</code> was\ncalled. It sends a chunk of the response body. This method may\nbe called multiple times to provide successive parts of the body.</p>\n\n<p>If <code>chunk</code> is a string, the second parameter\nspecifies how to encode it into a byte stream. By default the\n<code>encoding</code> is <code>'ascii'</code>.</p>\n\n<p><strong>Note</strong>: This is the raw HTTP body and has nothing to do with\nhigher-level multi-part body encodings that may be used.</p>\n\n<p>The first time <code>response.write()</code> is called, it will send the buffered\nheader information and the first body to the client. The second time\n<code>response.write()</code> is called, Node assumes you're going to be streaming\ndata, and sends that separately. That is, the response is buffered up to the\nfirst chunk of body.</p>\n\n<h3>response.end()</h3>\n\n<p>This method signals to the server that all of the response headers and body\nhas been sent; that server should consider this message complete.\nThe method, <code>response.end()</code>, MUST be called on each\nresponse.</p>\n\n<h2 id=http.Client>http.Client</h2>\n\n<p>An HTTP client is constructed with a server address as its\nargument, the returned handle is then used to issue one or more\nrequests.  Depending on the server connected to, the client might\npipeline the requests or reestablish the stream after each\nstream. <em>Currently the implementation does not pipeline requests.</em></p>\n\n<p>Example of connecting to <code>google.com</code>:</p>\n\n<pre><code>var sys = require('sys'),\n   http = require('http');\nvar google = http.createClient(80, 'www.google.com');\nvar request = google.request('GET', '/',\n  {'host': 'www.google.com'});\nrequest.end();\nrequest.addListener('response', function (response) {\n  sys.puts('STATUS: ' + response.statusCode);\n  sys.puts('HEADERS: ' + JSON.stringify(response.headers));\n  response.setEncoding('utf8');\n  response.addListener('data', function (chunk) {\n    sys.puts('BODY: ' + chunk);\n  });\n});\n</code></pre>\n\n<h3>http.createClient(port, host, secure, credentials)</h3>\n\n<p>Constructs a new HTTP client. <code>port</code> and\n<code>host</code> refer to the server to be connected to. A\nstream is not established until a request is issued.</p>\n\n<p><code>secure</code> is an optional boolean flag to enable https support and <code>credentials</code> is an optional credentials object from the crypto module, which may hold the client's private key, certificate, and a list of trusted CA certificates.</p>\n\n<p>If the connection is secure, but no explicit CA certificates are passed in the credentials, then node.js will default to the publicly trusted list of CA certificates, as given in http://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt</p>\n\n<h3>client.request([method], path, [request_headers])</h3>\n\n<p>Issues a request; if necessary establishes stream. Returns a <code>http.ClientRequest</code> instance.</p>\n\n<p><code>method</code> is optional and defaults to 'GET' if omitted.</p>\n\n<p><code>request_headers</code> is optional.\nAdditional request headers might be added internally\nby Node. Returns a <code>ClientRequest</code> object.</p>\n\n<p>Do remember to include the <code>Content-Length</code> header if you\nplan on sending a body. If you plan on streaming the body, perhaps\nset <code>Transfer-Encoding: chunked</code>.</p>\n\n<p><em>NOTE</em>: the request is not complete. This method only sends the header of\nthe request. One needs to call <code>request.end()</code> to finalize the request and\nretrieve the response.  (This sounds convoluted but it provides a chance for\nthe user to stream a body to the server with <code>request.write()</code>.)</p>\n\n<h3>client.verifyPeer()</h3>\n\n<p>Returns true or false depending on the validity of the server's certificate in the context of the defined or default list of trusted CA certificates.</p>\n\n<h3>client.getPeerCertificate()</h3>\n\n<p>Returns a JSON structure detailing the server's certificate, containing a dictionary with keys for the certificate 'subject', 'issuer', 'valid_from' and 'valid_to'</p>\n\n<h2 id=http.ClientRequest>http.ClientRequest</h2>\n\n<p>This object is created internally and returned from the <code>request()</code> method\nof a <code>http.Client</code>. It represents an <em>in-progress</em> request whose header has\nalready been sent.</p>\n\n<p>To get the response, add a listener for <code>'response'</code> to the request object.\n<code>'response'</code> will be emitted from the request object when the response\nheaders have been received.  The <code>'response'</code> event is executed with one\nargument which is an instance of <code>http.ClientResponse</code>.</p>\n\n<p>During the <code>'response'</code> event, one can add listeners to the\nresponse object; particularly to listen for the <code>'data'</code> event. Note that\nthe <code>'response'</code> event is called before any part of the response body is received,\nso there is no need to worry about racing to catch the first part of the\nbody. As long as a listener for <code>'data'</code> is added during the <code>'response'</code>\nevent, the entire body will be caught.</p>\n\n<pre><code>// Good\nrequest.addListener('response', function (response) {\n  response.addListener('data', function (chunk) {\n    sys.puts('BODY: ' + chunk);\n  });\n});\n\n// Bad - misses all or part of the body\nrequest.addListener('response', function (response) {\n  setTimeout(function () {\n    response.addListener('data', function (chunk) {\n      sys.puts('BODY: ' + chunk);\n    });\n  }, 10);\n});\n</code></pre>\n\n<p>This is a writable stream.</p>\n\n<p>This is an <code>EventEmitter</code> with the following events:</p>\n\n<h3>Event 'response'</h3>\n\n<p><code>function (response) { }</code></p>\n\n<p>Emitted when a response is received to this request. This event is emitted only once. The\n<code>response</code> argument will be an instance of <code>http.ClientResponse</code>.</p>\n\n<h3>request.write(chunk, encoding='ascii')</h3>\n\n<p>Sends a chunk of the body.  By calling this method\nmany times, the user can stream a request body to a\nserver--in that case it is suggested to use the\n<code>['Transfer-Encoding', 'chunked']</code> header line when\ncreating the request.</p>\n\n<p>The <code>chunk</code> argument should be an array of integers\nor a string.</p>\n\n<p>The <code>encoding</code> argument is optional and only\napplies when <code>chunk</code> is a string. The encoding\nargument should be either <code>'utf8'</code> or\n<code>'ascii'</code>. By default the body uses ASCII encoding,\nas it is faster.</p>\n\n<h3>request.end()</h3>\n\n<p>Finishes sending the request. If any parts of the body are\nunsent, it will flush them to the stream. If the request is\nchunked, this will send the terminating <code>'0\\r\\n\\r\\n'</code>.</p>\n\n<h2 id=http.ClientResponse>http.ClientResponse</h2>\n\n<p>This object is created when making a request with <code>http.Client</code>. It is\npassed to the <code>'response'</code> event of the request object.</p>\n\n<p>The response implements the <strong>readable stream</strong> interface.</p>\n\n<h3>Event: 'data'</h3>\n\n<p><code>function (chunk) {}</code></p>\n\n<p>Emitted when a piece of the message body is received.</p>\n\n<pre><code>Example: A chunk of the body is given as the single\nargument. The transfer-encoding has been decoded.  The\nbody chunk a String.  The body encoding is set with\n`response.setBodyEncoding()`.\n</code></pre>\n\n<h3>Event: 'end'</h3>\n\n<p><code>function () {}</code></p>\n\n<p>Emitted exactly once for each message. No arguments. After\nemitted no other events will be emitted on the response.</p>\n\n<h3>response.statusCode</h3>\n\n<p>The 3-digit HTTP response status code. E.G. <code>404</code>.</p>\n\n<h3>response.httpVersion</h3>\n\n<p>The HTTP version of the connected-to server. Probably either\n<code>'1.1'</code> or <code>'1.0'</code>.\nAlso <code>response.httpVersionMajor</code> is the first integer and\n<code>response.httpVersionMinor</code> is the second.</p>\n\n<h3>response.headers</h3>\n\n<p>The response headers.</p>\n\n<h3>response.setEncoding(encoding)</h3>\n\n<p>Set the encoding for the response body. Either <code>'utf8'</code> or <code>'binary'</code>.\nDefaults to <code>'binary'</code>.</p>\n\n<h3>response.pause()</h3>\n\n<p>Pauses response from emitting events.  Useful to throttle back a download.</p>\n\n<h3>response.resume()</h3>\n\n<p>Resumes a paused response.</p>\n\n<h3>response.client</h3>\n\n<p>A reference to the <code>http.Client</code> that this response belongs to.</p>\n\n<h2 id=net.Server>net.Server</h2>\n\n<p>This class is used to create a TCP or UNIX server.</p>\n\n<p>Here is an example of a echo server which listens for connections\non port 8124:</p>\n\n<pre><code>var net = require('net');\nvar server = net.createServer(function (stream) {\n  stream.setEncoding('utf8');\n  stream.addListener('connect', function () {\n    stream.write('hello\\r\\n');\n  });\n  stream.addListener('data', function (data) {\n    stream.write(data);\n  });\n  stream.addListener('end', function () {\n    stream.write('goodbye\\r\\n');\n    stream.end();\n  });\n});\nserver.listen(8124, 'localhost');\n</code></pre>\n\n<p>To listen on the socket <code>'/tmp/echo.sock'</code>, the last line would just be\nchanged to</p>\n\n<pre><code>server.listen('/tmp/echo.sock');\n</code></pre>\n\n<p>This is an EventEmitter with the following events:</p>\n\n<h3>Event: 'connection'</h3>\n\n<p><code>function (stream) {}</code></p>\n\n<p>Emitted when a new connection is made. <code>stream</code> is an instance of\n<code>net.Stream</code>.</p>\n\n<h3>Event: 'close'</h3>\n\n<p><code>function () {}</code></p>\n\n<p>Emitted when the server closes.</p>\n\n<h3>net.createServer(connectionListener)</h3>\n\n<p>Creates a new TCP server. The <code>connection_listener</code> argument is\nautomatically set as a listener for the <code>'connection'</code> event.</p>\n\n<h3>server.listen(port, host=null, callback=null)</h3>\n\n<p>Begin accepting connections on the specified <code>port</code> and <code>host</code>.  If the\n<code>host</code> is omitted, the server will accept connections directed to any\nIPv4 address (<code>INADDR_ANY</code>).</p>\n\n<p>This function is asynchronous. The last parameter <code>callback</code> will be called\nwhen the server has been bound.</p>\n\n<h3>server.listen(path, callback=null)</h3>\n\n<p>Start a UNIX socket server listening for connections on the given <code>path</code>.</p>\n\n<p>This function is asynchronous. The last parameter <code>callback</code> will be called\nwhen the server has been bound.</p>\n\n<h3>server.close()</h3>\n\n<p>Stops the server from accepting new connections. This function is\nasynchronous, the server is finally closed when the server emits a <code>'close'</code>\nevent.</p>\n\n<h2 id=net.Stream>net.Stream</h2>\n\n<p>This object is an abstraction of of a TCP or UNIX socket.  <code>net.Stream</code>\ninstance implement a duplex stream interface.  They can be created by the\nuser and used as a client (with <code>connect()</code>) or they can be created by Node\nand passed to the user through the <code>'connection'</code> event of a server.</p>\n\n<p><code>net.Stream</code> instances are an EventEmitters with the following events:</p>\n\n<h3>Event: 'connect'</h3>\n\n<p><code>function () { }</code></p>\n\n<p>Emitted when a stream connection successfully is established.\nSee <code>connect()</code>.</p>\n\n<h3>Event: 'secure'</h3>\n\n<p><code>function () { }</code></p>\n\n<p>Emitted when a stream connection successfully establishes a HTTPS handshake with its peer.</p>\n\n<h3>Event: 'data'</h3>\n\n<p><code>function (data) { }</code></p>\n\n<p>Emitted when data is received.  The argument <code>data</code> will be a <code>Buffer</code> or\n<code>String</code>.  Encoding of data is set by <code>stream.setEncoding()</code>.\n(See the section on Readable Streams for more infromation.)</p>\n\n<h3>Event: 'end'</h3>\n\n<p><code>function () { }</code></p>\n\n<p>Emitted when the other end of the stream sends a FIN packet. After this is\nemitted the <code>readyState</code> will be <code>'writeOnly'</code>. One should probably just\ncall <code>stream.end()</code> when this event is emitted.</p>\n\n<h3>Event: 'timeout'</h3>\n\n<p><code>function () { }</code></p>\n\n<p>Emitted if the stream times out from inactivity. This is only to notify that\nthe stream has been idle. The user must manually close the connection.</p>\n\n<p>See also: <code>stream.setTimeout()</code></p>\n\n<h3>Event: 'drain'</h3>\n\n<p><code>function () { }</code></p>\n\n<p>Emitted when the write buffer becomes empty. Can be used to throttle uploads.</p>\n\n<h3>Event: 'error'</h3>\n\n<p><code>function (exception) { }</code></p>\n\n<p>Emitted when an error occurs.  The <code>'close'</code> event will be called directly\nfollowing this event.</p>\n\n<h3>Event: 'close'</h3>\n\n<p><code>function () { }</code></p>\n\n<p>Emitted once the stream is fully closed. The argument <code>had_error</code> is a boolean which says if\nthe stream was closed due to a transmission\nerror.</p>\n\n<h3>net.createConnection(port, host='127.0.0.1')</h3>\n\n<p>Construct a new stream object and opens a stream to the specified <code>port</code>\nand <code>host</code>. If the second parameter is omitted, localhost is assumed.</p>\n\n<p>When the stream is established the <code>'connect'</code> event will be emitted.</p>\n\n<h3>stream.connect(port, host='127.0.0.1')</h3>\n\n<p>Opens a stream to the specified <code>port</code> and <code>host</code>. <code>createConnection()</code>\nalso opens a stream; normally this method is not needed. Use this only if\na stream is closed and you want to reuse the object to connect to another\nserver.</p>\n\n<p>This function is asynchronous. When the <code>'connect'</code> event is emitted the\nstream is established. If there is a problem connecting, the <code>'connect'</code>\nevent will not be emitted, the <code>'error'</code> event will be emitted with\nthe exception.</p>\n\n<h3>stream.remoteAddress</h3>\n\n<p>The string representation of the remote IP address. For example,\n<code>'74.125.127.100'</code> or <code>'2001:4860:a005::68'</code>.</p>\n\n<p>This member is only present in server-side connections.</p>\n\n<h3>stream.readyState</h3>\n\n<p>Either <code>'closed'</code>, <code>'open'</code>, <code>'opening'</code>, <code>'readOnly'</code>, or <code>'writeOnly'</code>.</p>\n\n<h3>stream.setEncoding(encoding)</h3>\n\n<p>Sets the encoding (either <code>'ascii'</code>, <code>'utf8'</code>, or <code>'binary'</code>) for data that is\nreceived.</p>\n\n<h3>stream.setSecure(credentials)</h3>\n\n<p>Enables HTTPS support for the stream, with the crypto module credentials specifying the private key and certificate of the stream, and optionally the CA certificates for use in peer authentication.</p>\n\n<p>If the credentials hold one ore more CA certificates, then the stream will request for the peer to submit a client certificate as part of the HTTPS connection handshake. The validity and content of this can be accessed via verifyPeer() and getPeerCertificate().</p>\n\n<h3>stream.verifyPeer()</h3>\n\n<p>Returns true or false depending on the validity of the peers's certificate in the context of the defined or default list of trusted CA certificates.</p>\n\n<h3>stream.getPeerCertificate()</h3>\n\n<p>Returns a JSON structure detailing the peer's certificate, containing a dictionary with keys for the certificate 'subject', 'issuer', 'valid_from' and 'valid_to'</p>\n\n<h3>stream.write(data, encoding='ascii')</h3>\n\n<p>Sends data on the stream. The second parameter specifies the encoding in\nthe case of a string--it defaults to ASCII because encoding to UTF8 is rather\nslow.</p>\n\n<p>Returns <code>true</code> if the entire data was flushed successfully to the kernel\nbuffer. Returns <code>false</code> if all or part of the data was queued in user memory.\n<code>'drain'</code> will be emitted when the buffer is again free.</p>\n\n<h3>stream.end()</h3>\n\n<p>Half-closes the stream. I.E., it sends a FIN packet. It is possible the\nserver will still send some data. After calling this <code>readyState</code> will be\n<code>'readOnly'</code>.</p>\n\n<h3>stream.destroy()</h3>\n\n<p>Ensures that no more I/O activity happens on this stream. Only necessary in\ncase of errors (parse error or so).</p>\n\n<h3>stream.pause()</h3>\n\n<p>Pauses the reading of data. That is, <code>'data'</code> events will not be emitted.\nUseful to throttle back an upload.</p>\n\n<h3>stream.resume()</h3>\n\n<p>Resumes reading after a call to <code>pause()</code>.</p>\n\n<h3>stream.setTimeout(timeout)</h3>\n\n<p>Sets the stream to timeout after <code>timeout</code> milliseconds of inactivity on\nthe stream. By default <code>net.Stream</code> do not have a timeout.</p>\n\n<p>When an idle timeout is triggered the stream will receive a <code>'timeout'</code>\nevent but the connection will not be severed. The user must manually <code>end()</code>\nor <code>destroy()</code> the stream.</p>\n\n<p>If <code>timeout</code> is 0, then the existing idle timeout is disabled.</p>\n\n<h3>stream.setNoDelay(noDelay=true)</h3>\n\n<p>Disables the Nagle algorithm. By default TCP connections use the Nagle\nalgorithm, they buffer data before sending it off. Setting <code>noDelay</code> will\nimmediately fire off data each time <code>stream.write()</code> is called.</p>\n\n<h3>stream.setKeepAlive(enable=false, initialDelay)</h3>\n\n<p>Enable/disable keep-alive functionality, and optionally set the initial\ndelay before the first keepalive probe is sent on an idle stream.\nSet <code>initialDelay</code> (in milliseconds) to set the delay between the last\ndata packet received and the first keepalive probe. Setting 0 for\ninitialDelay will leave the value unchanged from the default\n(or previous) setting.</p>\n\n<h2 id=Crypto>Crypto</h2>\n\n<p>Use <code>require('crypto')</code> to access this module.</p>\n\n<p>The crypto module requires OpenSSL to be available on the underlying platform. It offers a way of encapsulating secure credentials to be used as part of a secure HTTPS net or http connection.</p>\n\n<p>It also offers a set of wrappers for OpenSSL's hash, hmac, cipher, decipher, sign and verify methods.</p>\n\n<h3>crypto.createCredentials(details)</h3>\n\n<p>Creates a credentials object, with the optional details being a dictionary with keys:</p>\n\n<p><code>key</code> : a string holding the PEM encoded private key</p>\n\n<p><code>cert</code> : a string holding the PEM encoded certificate</p>\n\n<p><code>ca</code> : either a string or list of strings of PEM encoded CA certificates to trust.</p>\n\n<p>If no 'ca' details are given, then node.js will use the default publicly trusted list of CAs as given in\nhttp://mxr.mozilla.org/mozilla/source/security/nss/lib/ckfw/builtins/certdata.txt</p>\n\n<h3>crypto.createHash(algorithm)</h3>\n\n<p>Creates and returns a hash object, a cryptographic hash with the given algorithm which can be used to generate hash digests.</p>\n\n<p><code>algorithm</code> is dependent on the available algorithms supported by the version of OpenSSL on the platform. Examples are sha1, md5, sha256, sha512, etc. On recent releases, <code>openssl list-message-digest-algorithms</code> will display the available digest algorithms.</p>\n\n<h3>hash.update(data)</h3>\n\n<p>Updates the hash content with the given <code>data</code>. This can be called many times with new data as it is streamed.</p>\n\n<h3>hash.digest(encoding)</h3>\n\n<p>Calculates the digest of all of the passed data to be hashed. The <code>encoding</code> can be 'hex', 'binary' or 'base64'.</p>\n\n<h3>crypto.createHmac(algorithm, key)</h3>\n\n<p>Creates and returns a hmac object, a cryptographic hmac with the given algorithm and key.</p>\n\n<p><code>algorithm</code> is dependent on the available algorithms supported by OpenSSL - see createHash above.\n<code>key</code> is the hmac key to be used.</p>\n\n<h3>hmac.update(data)</h3>\n\n<p>Update the hmac content with the given <code>data</code>. This can be called many times with new data as it is streamed.</p>\n\n<h3>hmac.digest(encoding)</h3>\n\n<p>Calculates the digest of all of the passed data to the hmac. The <code>encoding</code> can be 'hex', 'binary' or 'base64'.</p>\n\n<h3>crypto.createCipher(algorithm, key)</h3>\n\n<p>Creates and returns a cipher object, with the given algorithm and key.</p>\n\n<p><code>algorithm</code> is dependent on OpenSSL, examples are aes192, etc. On recent releases, <code>openssl list-cipher-algorithms</code> will display the available cipher algorithms.</p>\n\n<h3>cipher.update(data, input_encoding, output_encoding)</h3>\n\n<p>Updates the cipher with <code>data</code>, the encoding of which is given in <code>input_encoding</code> and can be 'utf8', 'ascii' or 'binary'. The <code>output_encoding</code> specifies the output format of the enciphered data, and can be 'binary', 'base64'  or 'hex'.</p>\n\n<p>Returns the enciphered contents, and can be called many times with new data as it is streamed.</p>\n\n<h3>cipher.final(output_encoding)</h3>\n\n<p>Returns any remaining enciphered contents, with <code>output_encoding</code> as update above.</p>\n\n<h3>crypto.createDecipher(algorithm, key)</h3>\n\n<p>Creates and returns a decipher object, with the given algorithm and key. This is the mirror of the cipher object above.</p>\n\n<h3>decipher.update(data, input_encoding, output_encoding)</h3>\n\n<p>Updates the decipher with <code>data</code>, which is encoded in 'binary', 'base64' or 'hex'. The <code>output_decoding</code> specifies in what format to return the deciphered plaintext - either 'binary', 'ascii' or 'utf8'.</p>\n\n<h3>decipher.final(output_encoding)</h3>\n\n<p>Returns any remaining plaintext which is deciphered, with `output_encoding' as update above.</p>\n\n<h3>crypto.createSign(algorithm)</h3>\n\n<p>Creates and returns a signing object, with the given algorithm. On recent OpenSSL releases, <code>openssl list-public-key-algorithms</code> will display the available signing algorithms. Examples are 'RSA-SHA256'.</p>\n\n<h3>signer.update(data)</h3>\n\n<p>Updates the signer object with data. This can be called many times with new data as it is streamed.</p>\n\n<h3>signer.sign(private_key, output_format)</h3>\n\n<p>Calculates the signature on all the updated data passed through the signer. <code>private_key</code> is a string containing the PEM encoded private key for signing.</p>\n\n<p>Returns the signature in <code>output_format</code> which can be 'binary', 'hex' or 'base64'</p>\n\n<h3>crypto.createVerify(algorithm)</h3>\n\n<p>Creates and returns a verification object, with the given algorithm. This is the mirror of the signing object above.</p>\n\n<h3>verifier.update(data)</h3>\n\n<p>Updates the verifyer object with data. This can be called many times with new data as it is streamed.</p>\n\n<h3>verifier.verify(public_key, signature, signature_format)</h3>\n\n<p>Verifies the signed data by using the <code>public_key</code> which is a string containing the PEM encoded public key, and <code>signature</code>, which is the previously calculates signature for the data, in the <code>signature_format</code> which can be 'binary', 'hex' or 'base64'.</p>\n\n<p>Returns true or false depending on the validity of the signature for the data and public key.</p>\n\n<h2 id=DNS>DNS</h2>\n\n<p>Use <code>require('dns')</code> to access this module.</p>\n\n<p>Here is an example which resolves <code>'www.google.com'</code> then reverse\nresolves the IP addresses which are returned.</p>\n\n<pre><code>var dns = require('dns'),\n    sys = require('sys');\n\ndns.resolve4('www.google.com', function (err, addresses) {\n  if (err) throw err;\n\n  sys.puts('addresses: ' + JSON.stringify(addresses));\n\n  for (var i = 0; i &lt; addresses.length; i++) {\n    var a = addresses[i];\n    dns.reverse(a, function (err, domains) {\n      if (err) {\n        sys.puts('reverse for ' + a + ' failed: ' + \n          err.message);\n      } else {\n        sys.puts('reverse for ' + a + ': ' + \n          JSON.stringify(domains));\n      }\n    });\n  }\n});\n</code></pre>\n\n<h3>dns.resolve(domain, rrtype = 'A', callback)</h3>\n\n<p>Resolves a domain (e.g. <code>'google.com'</code>) into an array of the record types\nspecified by rrtype. Valid rrtypes are <code>A</code> (IPV4 addresses), <code>AAAA</code> (IPV6\naddresses), <code>MX</code> (mail exchange records), <code>TXT</code> (text records), <code>SRV</code> (SRV\nrecords), and <code>PTR</code> (used for reverse IP lookups).</p>\n\n<p>The callback has arguments <code>(err, addresses)</code>.  The type of each item\nin <code>addresses</code> is determined by the record type, and described in the\ndocumentation for the corresponding lookup methods below.</p>\n\n<p>On error, <code>err</code> would be an instanceof <code>Error</code> object, where <code>err.errno</code> is\none of the error codes listed below and <code>err.message</code> is a string describing\nthe error in English.</p>\n\n<h3>dns.resolve4(domain, callback)</h3>\n\n<p>The same as <code>dns.resolve()</code>, but only for IPv4 queries (<code>A</code> records).\n<code>addresses</code> is an array of IPv4 addresses (e.g.<br>\n<code>['74.125.79.104', '74.125.79.105', '74.125.79.106']</code>).</p>\n\n<h3>dns.resolve6(domain, callback)</h3>\n\n<p>The same as <code>dns.resolve4()</code> except for IPv6 queries (an <code>AAAA</code> query).</p>\n\n<h3>dns.resolveMx(domain, callback)</h3>\n\n<p>The same as <code>dns.resolve()</code>, but only for mail exchange queries (<code>MX</code> records).</p>\n\n<p><code>addresses</code> is an array of MX records, each with a priority and an exchange\nattribute (e.g. <code>[{'priority': 10, 'exchange': 'mx.example.com'},...]</code>).</p>\n\n<h3>dns.resolveTxt(domain, callback)</h3>\n\n<p>The same as <code>dns.resolve()</code>, but only for text queries (<code>TXT</code> records).\n<code>addresses</code> is an array of the text records available for <code>domain</code> (e.g.,\n<code>['v=spf1 ip4:0.0.0.0 ~all']</code>).</p>\n\n<h3>dns.resolveSrv(domain, callback)</h3>\n\n<p>The same as <code>dns.resolve()</code>, but only for service records (<code>SRV</code> records).\n<code>addresses</code> is an array of the SRV records available for <code>domain</code>. Properties\nof SRV records are priority, weight, port, and name (e.g.,\n<code>[{'priority': 10, {'weight': 5, 'port': 21223, 'name': 'service.example.com'}, ...]</code>).</p>\n\n<h3>dns.reverse(ip, callback)</h3>\n\n<p>Reverse resolves an ip address to an array of domain names.</p>\n\n<p>The callback has arguments <code>(err, domains)</code>.</p>\n\n<p>If there an an error, <code>err</code> will be non-null and an instanceof the Error\nobject.</p>\n\n<p>Each DNS query can return an error code.</p>\n\n<ul>\n<li><code>dns.TEMPFAIL</code>: timeout, SERVFAIL or similar.</li>\n<li><code>dns.PROTOCOL</code>: got garbled reply.</li>\n<li><code>dns.NXDOMAIN</code>: domain does not exists.</li>\n<li><code>dns.NODATA</code>: domain exists but no data of reqd type.</li>\n<li><code>dns.NOMEM</code>: out of memory while processing.</li>\n<li><code>dns.BADQUERY</code>: the query is malformed.</li>\n</ul>\n\n\n<h2 id=Assert>Assert</h2>\n\n<p>This module is used for writing unit tests for your applications, you can\naccess it with <code>require('assert')</code>.</p>\n\n<h3>assert.fail(actual, expected, message, operator)</h3>\n\n<p>Tests if <code>actual</code> is equal to <code>expected</code> using the operator provided.</p>\n\n<h3>assert.ok(value, message)</h3>\n\n<p>Tests if value is a <code>true</code> value, it is equivalent to <code>assert.equal(true, value, message);</code></p>\n\n<h3>assert.equal(actual, expected, message)</h3>\n\n<p>Tests shallow, coercive equality with the equal comparison operator ( <code>==</code> ).</p>\n\n<h3>assert.notEqual(actual, expected, message)</h3>\n\n<p>Tests shallow, coercive non-equality with the not equal comparison operator ( <code>!=</code> ).</p>\n\n<h3>assert.deepEqual(actual, expected, message)</h3>\n\n<p>Tests for deep equality.</p>\n\n<h3>assert.notDeepEqual(actual, expected, message)</h3>\n\n<p>Tests for any deep inequality.</p>\n\n<h3>assert.strictEqual(actual, expected, message)</h3>\n\n<p>Tests strict equality, as determined by the strict equality operator ( <code>===</code> )</p>\n\n<h3>assert.notStrictEqual(actual, expected, message)</h3>\n\n<p>Tests strict non-equality, as determined by the strict not equal operator ( <code>!==</code> )</p>\n\n<h3>assert.throws(block, error, message)</h3>\n\n<p>Expects <code>block</code> to throw an error.</p>\n\n<h3>assert.doesNotThrow(block, error, message)</h3>\n\n<p>Expects <code>block</code> not to throw an error.</p>\n\n<h3>assert.ifError(value)</h3>\n\n<p>Tests if value is not a false value, throws if it is a true value. Useful when testing the first argument, <code>error</code> in callbacks.</p>\n\n<h2 id=Path>Path</h2>\n\n<p>This module contains utilities for dealing with file paths.  Use\n<code>require('path')</code> to use it.  It provides the following methods:</p>\n\n<h3>path.join(/<em> path1, path2, ... </em>/)</h3>\n\n<p>Join all arguments together and resolve the resulting path.  Example:</p>\n\n<pre><code>node&gt; require('path').join(\n...   '/foo', 'bar', 'baz/asdf', 'quux', '..')\n'/foo/bar/baz/asdf'\n</code></pre>\n\n<h3>path.normalizeArray(arr)</h3>\n\n<p>Normalize an array of path parts, taking care of <code>'..'</code> and <code>'.'</code> parts.  Example:</p>\n\n<pre><code>path.normalizeArray(['', \n  'foo', 'bar', 'baz', 'asdf', 'quux', '..'])\n// returns\n[ '', 'foo', 'bar', 'baz', 'asdf' ]\n</code></pre>\n\n<h3>path.normalize(p)</h3>\n\n<p>Normalize a string path, taking care of <code>'..'</code> and <code>'.'</code> parts.  Example:</p>\n\n<pre><code>path.normalize('/foo/bar/baz/asdf/quux/..')\n// returns\n'/foo/bar/baz/asdf'\n</code></pre>\n\n<h3>path.dirname(p)</h3>\n\n<p>Return the directory name of a path.  Similar to the Unix <code>dirname</code> command.  Example:</p>\n\n<pre><code>path.dirname('/foo/bar/baz/asdf/quux')\n// returns\n'/foo/bar/baz/asdf'\n</code></pre>\n\n<h3>path.basename(p, ext)</h3>\n\n<p>Return the last portion of a path.  Similar to the Unix <code>basename</code> command.  Example:</p>\n\n<pre><code>path.basename('/foo/bar/baz/asdf/quux.html')\n// returns\n'quux.html'\n\npath.basename('/foo/bar/baz/asdf/quux.html', '.html')\n// returns\n'quux'\n</code></pre>\n\n<h3>path.extname(p)</h3>\n\n<p>Return the extension of the path.  Everything after the last '.' in the last portion\nof the path.  If there is no '.' in the last portion of the path or the only '.' is\nthe first character, then it returns an empty string.  Examples:</p>\n\n<pre><code>path.extname('index.html')\n// returns \n'.html'\n\npath.extname('index')\n// returns\n''\n</code></pre>\n\n<h3>path.exists(p, callback)</h3>\n\n<p>Test whether or not the given path exists.  Then, call the <code>callback</code> argument with either true or false.  Example:</p>\n\n<pre><code>path.exists('/etc/passwd', function (exists) {\n  sys.debug(exists ? \"it's there\" : \"no passwd!\");\n});\n</code></pre>\n\n<h2 id=URL>URL</h2>\n\n<p>This module has utilities for URL resolution and parsing.\nCall <code>require('url')</code> to use it.</p>\n\n<p>Parsed URL objects have some or all of the following fields, depending on\nwhether or not they exist in the URL string. Any parts that are not in the URL\nstring will not be in the parsed object. Examples are shown for the URL</p>\n\n<p><code>'http://user:pass@host.com:8080/p/a/t/h?query=string#hash'</code></p>\n\n<ul>\n<li><p><code>href</code></p>\n\n<p>The full URL that was originally parsed. Example:\n<code>'http://user:pass@host.com:8080/p/a/t/h?query=string#hash'</code></p></li>\n<li><p><code>protocol</code></p>\n\n<p>The request protocol.  Example: <code>'http:'</code></p></li>\n<li><p><code>host</code></p>\n\n<p>The full host portion of the URL, including port and authentication information. Example:\n<code>'user:pass@host.com:8080'</code></p></li>\n<li><p><code>auth</code></p>\n\n<p>The authentication information portion of a URL.  Example: <code>'user:pass'</code></p></li>\n<li><p><code>hostname</code></p>\n\n<p>Just the hostname portion of the host.  Example: <code>'host.com'</code></p></li>\n<li><p><code>port</code></p>\n\n<p>The port number portion of the host.  Example: <code>'8080'</code></p></li>\n<li><p><code>pathname</code></p>\n\n<p>The path section of the URL, that comes after the host and before the query, including the initial slash if present.  Example: <code>'/p/a/t/h'</code></p></li>\n<li><p><code>search</code></p>\n\n<p>The 'query string' portion of the URL, including the leading question mark. Example: <code>'?query=string'</code></p></li>\n<li><p><code>query</code></p>\n\n<p>Either the 'params' portion of the query string, or a querystring-parsed object. Example:\n<code>'query=string'</code> or <code>{'query':'string'}</code></p></li>\n<li><p><code>hash</code></p>\n\n<p>The 'fragment' portion of the URL including the pound-sign. Example: <code>'#hash'</code></p></li>\n</ul>\n\n\n<p>The following methods are provided by the URL module:</p>\n\n<h3>url.parse(urlStr, parseQueryString=false)</h3>\n\n<p>Take a URL string, and return an object.  Pass <code>true</code> as the second argument to also parse\nthe query string using the <code>querystring</code> module.</p>\n\n<h3>url.format(urlObj)</h3>\n\n<p>Take a parsed URL object, and return a formatted URL string.</p>\n\n<h3>url.resolve(from, to)</h3>\n\n<p>Take a base URL, and a href URL, and resolve them as a browser would for an anchor tag.</p>\n\n<h2 id=\"Query String\">Query String</h2>\n\n<p>This module provides utilities for dealing with query strings.  It provides the following methods:</p>\n\n<h3>querystring.stringify(obj, sep='&amp;', eq='=', munge=true)</h3>\n\n<p>Serialize an object to a query string.  Optionally override the default separator and assignment characters.\nExample:</p>\n\n<pre><code>querystring.stringify({foo: 'bar'})\n// returns\n'foo=bar'\n\nquerystring.stringify({foo: 'bar', baz: 'bob'}, ';', ':')\n// returns\n'foo:bar;baz:bob'\n</code></pre>\n\n<p>By default, this function will perform PHP/Rails-style parameter mungeing for arrays and objects used as\nvalues within <code>obj</code>.\nExample:</p>\n\n<pre><code>querystring.stringify({foo: 'bar', foo: 'baz', foo: 'boz'})\n// returns\n'foo[]=bar&amp;foo[]=baz&amp;foo[]=boz'\n\nquerystring.stringify({foo: {bar: 'baz'}})\n// returns\n'foo[bar]=baz'\n</code></pre>\n\n<p>If you wish to disable the array mungeing (e.g. when generating parameters for a Java servlet), you\ncan set the <code>munge</code> argument to <code>false</code>.\nExample:</p>\n\n<pre><code>querystring.stringify({foo: 'bar', foo: 'baz', foo: 'boz'}, '&amp;', '=', false)\n// returns\n'foo=bar&amp;foo=baz&amp;foo=boz'\n</code></pre>\n\n<p>Note that when <code>munge</code> is <code>false</code>, parameter names with object values will still be munged.</p>\n\n<h3>querystring.parse(str, sep='&amp;', eq='=')</h3>\n\n<p>Deserialize a query string to an object.  Optionally override the default separator and assignment characters.</p>\n\n<pre><code>querystring.parse('a=b&amp;b=c')\n// returns\n{ 'a': 'b'\n, 'b': 'c'\n}\n</code></pre>\n\n<p>This function can parse both munged and unmunged query strings (see <code>stringify</code> for details).</p>\n\n<h3>querystring.escape</h3>\n\n<p>The escape function used by <code>querystring.stringify</code>, provided so that it could be overridden if necessary.</p>\n\n<h3>querystring.unescape</h3>\n\n<p>The unescape function used by <code>querystring.parse</code>, provided so that it could be overridden if necessary.</p>\n\n<h2 id=REPL>REPL</h2>\n\n<p>A Read-Eval-Print-Loop (REPL) is available both as a standalone program and easily\nincludable in other programs.  REPL provides a way to interactively run\nJavaScript and see the results.  It can be used for debugging, testing, or\njust trying things out.</p>\n\n<p>By executing <code>node</code> without any arguments from the command-line you will be\ndropped into the REPL. It has simplistic emacs line-editting.</p>\n\n<pre><code>mjr:~$ node\nType '.help' for options.\nnode&gt; a = [ 1, 2, 3];\n[ 1, 2, 3 ]\nnode&gt; a.forEach(function (v) {\n...   sys.puts(v);\n...   });\n1\n2\n3\n</code></pre>\n\n<p>For advanced line-editors, start node with the environmental variable <code>NODE_NO_READLINE=1</code>.\nThis will start the REPL in canonical terminal settings which will allow you to use with <code>rlwrap</code>.</p>\n\n<p>For example, you could add this to your bashrc file:</p>\n\n<pre><code>alias node=\"env NODE_NO_READLINE=1 rlwrap node\"\n</code></pre>\n\n<h3>repl.start(prompt, stream)</h3>\n\n<p>Starts a REPL with <code>prompt</code> as the prompt and <code>stream</code> for all I/O.  <code>prompt</code>\nis optional and defaults to <code>node&gt;</code>.  <code>stream</code> is optional and defaults to\n<code>process.openStdin()</code>.</p>\n\n<p>Multiple REPLs may be started against the same running instance of node.  Each\nwill share the same global object but will have unique I/O.</p>\n\n<p>Here is an example that starts a REPL on stdin, a Unix socket, and a TCP socket:</p>\n\n<pre><code>var sys = require(\"sys\"),\n    net = require(\"net\"),\n    repl = require(\"repl\");\n\nconnections = 0;\n\nrepl.start(\"node via stdin&gt; \");\n\nnet.createServer(function (socket) {\n  connections += 1;\n  repl.start(\"node via Unix socket&gt; \", socket);\n}).listen(\"/tmp/node-repl-sock\");\n\nnet.createServer(function (socket) {\n  connections += 1;\n  repl.start(\"node via TCP socket&gt; \", socket);\n}).listen(5001);\n</code></pre>\n\n<p>Running this program from the command line will start a REPL on stdin.  Other\nREPL clients may connect through the Unix socket or TCP socket. <code>telnet</code> is useful\nfor connecting to TCP sockets, and <code>socat</code> can be used to connect to both Unix and\nTCP sockets.</p>\n\n<p>By starting a REPL from a Unix socket-based server instead of stdin, you can\nconnect to a long-running node process without restarting it.</p>\n\n<h3>REPL Features</h3>\n\n<p>Inside the REPL, Control+D will exit.  Multi-line expressions can be input.</p>\n\n<p>The special variable <code>_</code> (underscore) contains the result of the last expression.</p>\n\n<pre><code>node&gt; [ \"a\", \"b\", \"c\" ]\n[ 'a', 'b', 'c' ]\nnode&gt; _.length \n3\nnode&gt; _ += 1\n4\n</code></pre>\n\n<p>The REPL provides access to any variables in the global scope. You can expose a variable\nto the REPL explicitly by assigning it to the <code>scope</code> object associated with each\n<code>REPLServer</code>.  For example:</p>\n\n<pre><code>// repl_test.js\nvar repl = require(\"repl\"),\n    msg = \"message\";\n\nrepl.start().scope.m = msg;\n</code></pre>\n\n<p>Things in the <code>scope</code> object appear as local within the REPL:</p>\n\n<pre><code>mjr:~$ node repl_test.js \nnode&gt; m\n'message'\n</code></pre>\n\n<p>There are a few special REPL commands:</p>\n\n<ul>\n<li><p><code>.break</code> - While inputting a multi-line expression, sometimes you get lost or just don't care\nabout completing it.  <code>.break</code> will start over.</p></li>\n<li><p><code>.clear</code> - Resets the <code>scope</code> object to an empty object and clears any multi-line expression.</p></li>\n<li><p><code>.exit</code> - Close the I/O stream, which will cause the REPL to exit.</p></li>\n<li><p><code>.help</code> - Show this list of special commands.</p></li>\n</ul>\n\n\n<h2 id=Modules>Modules</h2>\n\n<p>Node uses the CommonJS module system.</p>\n\n<p>Node has a simple module loading system.  In Node, files and modules are in\none-to-one correspondence.  As an example, <code>foo.js</code> loads the module\n<code>circle.js</code> in the same directory.</p>\n\n<p>The contents of <code>foo.js</code>:</p>\n\n<pre><code>var circle = require('./circle'),\n    sys = require('sys');\nsys.puts( 'The area of a circle of radius 4 is '\n  + circle.area(4));\n</code></pre>\n\n<p>The contents of <code>circle.js</code>:</p>\n\n<pre><code>var PI = 3.14;\n\nexports.area = function (r) {\n  return PI * r * r;\n};\n\nexports.circumference = function (r) {\n  return 2 * PI * r;\n};\n</code></pre>\n\n<p>The module <code>circle.js</code> has exported the functions <code>area()</code> and\n<code>circumference()</code>.  To export an object, add to the special <code>exports</code>\nobject.  (Alternatively, one can use <code>this</code> instead of <code>exports</code>.) Variables\nlocal to the module will be private. In this example the variable <code>PI</code> is\nprivate to <code>circle.js</code>. The function <code>puts()</code> comes from the module <code>'sys'</code>,\nwhich is a built-in module. Modules which are not prefixed by <code>'./'</code> are\nbuilt-in module--more about this later.</p>\n\n<p>A module prefixed with <code>'./'</code> is relative to the file calling <code>require()</code>.\nThat is, <code>circle.js</code> must be in the same directory as <code>foo.js</code> for\n<code>require('./circle')</code> to find it.</p>\n\n<p>Without the leading <code>'./'</code>, like <code>require('assert')</code> the module is searched\nfor in the <code>require.paths</code> array. <code>require.paths</code> on my system looks like\nthis:</p>\n\n<p><code>[ '/home/ryan/.node_libraries' ]</code></p>\n\n<p>That is, when <code>require('assert')</code> is called Node looks for:</p>\n\n<ul>\n<li>1: <code>/home/ryan/.node_libraries/assert.js</code></li>\n<li>2: <code>/home/ryan/.node_libraries/assert.node</code></li>\n<li>3: <code>/home/ryan/.node_libraries/assert/index.js</code></li>\n<li>4: <code>/home/ryan/.node_libraries/assert/index.node</code></li>\n</ul>\n\n\n<p>interrupting once a file is found. Files ending in <code>'.node'</code> are binary Addon\nModules; see 'Addons' below. <code>'index.js'</code> allows one to package a module as\na directory.</p>\n\n<p><code>require.paths</code> can be modified at runtime by simply unshifting new\npaths onto it, or at startup with the <code>NODE_PATH</code> environmental\nvariable (which should be a list of paths, colon separated).</p>\n\n<h2 id=Addons>Addons</h2>\n\n<p>Addons are dynamically linked shared objects. They can provide glue to C and\nC++ libraries. The API (at the moment) is rather complex, involving\nknowledge of several libraries:</p>\n\n<ul>\n<li><p>V8 JavaScript, a C++ library. Used for interfacing with JavaScript:\ncreating objects, calling functions, etc.  Documented mostly in the\n<code>v8.h</code> header file (<code>deps/v8/include/v8.h</code> in the Node source tree).</p></li>\n<li><p>libev, C event loop library. Anytime one needs to wait for a file\ndescriptor to become readable, wait for a timer, or wait for a signal to\nreceived one will need to interface with libev.  That is, if you perform\nany I/O, libev will need to be used.  Node uses the <code>EV_DEFAULT</code> event\nloop.  Documentation can be found http:/cvs.schmorp.de/libev/ev.html[here].</p></li>\n<li><p>libeio, C thread pool library. Used to execute blocking POSIX system\ncalls asynchronously. Mostly wrappers already exist for such calls, in\n<code>src/file.cc</code> so you will probably not need to use it. If you do need it,\nlook at the header file <code>deps/libeio/eio.h</code>.</p></li>\n<li><p>Internal Node libraries. Most importantly is the <code>node::ObjectWrap</code>\nclass which you will likely want to derive from.</p></li>\n<li><p>Others. Look in <code>deps/</code> for what else is available.</p></li>\n</ul>\n\n\n<p>Node statically compiles all its dependencies into the executable. When\ncompiling your module, you don't need to worry about linking to any of these\nlibraries.</p>\n\n<p>To get started let's make a small Addon which does the following except in\nC++:</p>\n\n<pre><code>exports.hello = 'world';\n</code></pre>\n\n<p>To get started we create a file <code>hello.cc</code>:</p>\n\n<pre><code>#include &lt;v8.h&gt;\n\nusing namespace v8;\n\nextern 'C' void\ninit (Handle&lt;Object&gt; target) \n{\n  HandleScope scope;\n  target-&gt;Set(String::New(\"hello\"), String::New(\"World\"));\n}\n</code></pre>\n\n<p>This source code needs to be built into <code>hello.node</code>, the binary Addon. To\ndo this we create a file called <code>wscript</code> which is python code and looks\nlike this:</p>\n\n<pre><code>srcdir = '.'\nblddir = 'build'\nVERSION = '0.0.1'\n\ndef set_options(opt):\n  opt.tool_options('compiler_cxx')\n\ndef configure(conf):\n  conf.check_tool('compiler_cxx')\n  conf.check_tool('node_addon')\n\ndef build(bld):\n  obj = bld.new_task_gen('cxx', 'shlib', 'node_addon')\n  obj.target = 'hello'\n  obj.source = 'hello.cc'\n</code></pre>\n\n<p>Running <code>node-waf configure build</code> will create a file\n<code>build/default/hello.node</code> which is our Addon.</p>\n\n<p><code>node-waf</code> is just http://code.google.com/p/waf/[WAF], the python-based build system. <code>node-waf</code> is\nprovided for the ease of users.</p>\n\n<p>All Node addons must export a function called <code>init</code> with this signature:</p>\n\n<pre><code>extern 'C' void init (Handle&lt;Object&gt; target)\n</code></pre>\n\n<p>For the moment, that is all the documentation on addons. Please see\n<a href=\"http://github.com/ry/node_postgres\">http://github.com/ry/node_postgres</a> for a real example.</p>\n</div>\n</div>\n<script src=\"./jquery.js\"></script>\n<script src=\"./sh_main.js\"></script>\n<script src=\"./sh_javascript.min.js\"></script>\n<script src=\"./doc.js\"></script>\n</body>"})