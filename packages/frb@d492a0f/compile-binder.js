function compile(e){return compile.semantics.compile(e)}var compileObserver=require("./compile-observer"),Observers=require("./observers"),Binders=require("./binders"),solve=require("./algebra");module.exports=compile,compile.semantics={compilers:{property:Binders.makePropertyBinder,get:Binders.makeGetBinder,has:Binders.makeHasBinder,rangeContent:Binders.makeRangeContentBinder,mapContent:Binders.makeMapContentBinder,reversed:Binders.makeReversedBinder},compile:function(e){var t=this.compilers;if("equals"===e.type){var n=this.compile(e.args[0]),a=compileObserver(e.args[1]);return Binders.makeEqualityBinder(n,a)}if("if"===e.type){var s=compileObserver(e.args[0]),r=this.compile(e.args[1]),i=this.compile(e.args[2]);return Binders.makeConditionalBinder(s,r,i)}if("everyBlock"===e.type){var o=compileObserver(e.args[0]),l=solve(e.args[1],{type:"literal",value:!0}),c=this.compile(l[0]),p=compileObserver(l[1]);return Binders.makeEveryBlockBinder(o,c,p)}if("rangeContent"===e.type){var h,u=compileObserver(e.args[0]);try{h=this.compile(e.args[0])}catch(d){h=Function.noop}return Binders.makeRangeContentBinder(u,h)}if(t.hasOwnProperty(e.type)){var g=e.args.map(compileObserver,compileObserver.semantics);return t[e.type].apply(null,g)}throw Error("Can't compile binder for "+JSON.stringify(e.type))}};